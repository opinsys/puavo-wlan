#!/bin/bash

set -eubm

on_exit()
{
    local -r exitval=$?

    ## Do not exit or terminate on error or signal anymore. We are
    ## already exiting and it would be shame to exit while exiting, yo
    ## dawg.
    set +eu
    trap '' EXIT HUP INT QUIT ABRT ALRM TERM USR1 USR2

    ## Kill our child processes. There is no reason to let Init adopt
    ## them when we die.
    pkill -TERM -P $$

    rm -rf "${PWAP_MDNS_RUNDIR}"

    exit $exitval
}

parse_args()
{
    PWAP_MDNS_ARGS_DAEMON=0

    if [ $# -eq 1 ]; then
        if [ "$1" = "--daemon" ]; then
            PWAP_MDNS_ARGS_DAEMON=1
            return 0
        fi
        echo "unexpected argument '$1'" >&2
        echo "Usage: $(basename $0) [--daemon]" >&2
        return 1
    elif [ $# -gt 2 ]; then
        echo "too many arguments" >&2
        echo "Usage: $(basename $0) [--daemon]" >&2
        return 1
    fi
}

write_avahi_services()
{
    local puavo_domain
    local puavo_hostname
    local puavo_api_server
    local json_objects
    local json_object
    local printer_name
    local printer_host
    local printer_path
    local printer_location
    local printer_type

    puavo_domain=$(cat /etc/puavo/domain)
    puavo_hostname=$(cat /etc/puavo/hostname)
    puavo_api_server=$(puavo-resolve-api-server)

    json_objects=$(wget -O - -q --ca-certificate /etc/puavo/certs/rootca.pem \
        --header 'Authorization: Bootserver' \
        "${puavo_api_server}/v3/devices/${puavo_hostname}/wireless_printer_queues" \
        | jq -c '.[]')

    echo "${json_objects}" | while read json_object; do
        printer_name=$(echo "${json_object}" | jq -r '.name')
        printer_host="cups.${puavo_domain}."
        printer_path="printers/${printer_name}"
        printer_location=$(echo "${json_object}" | jq -r '.location')
        printer_type=$(echo "${json_object}" | jq -r '.type')

        sed -e "s|#{PWAP_MDNS_PRINTER_NAME}|${printer_name}|g" \
            -e "s|#{PWAP_MDNS_PRINTER_HOST}|${printer_host}|g" \
            -e "s|#{PWAP_MDNS_PRINTER_PATH}|${printer_path}|g" \
            -e "s|#{PWAP_MDNS_PRINTER_LOCATION}|${printer_location}|g" \
            -e "s|#{PWAP_MDNS_PRINTER_TYPE}|${printer_type}|g" \
            "${PWAP_MDNS_DATADIR}/printer.service.in" >"/etc/avahi/services/${printer_name}.service"
    done
}

write_avahi_conf()
{
    local tap_iface
    local bridge_iface
    local bridge_ifaces=''
    local tmpfile

    while read tap_iface bridge_iface; do
        if [ -z "${bridge_iface}" ]; then
            bridge_ifaces="${bridge_iface}"
        else
            bridge_ifaces="${bridge_ifaces}, ${bridge_iface}"
        fi
    done <"${PWAP_MDNS_STATEDIR}/networkcache"

    tmpfile=$(mktemp)
    sed -e "s|#{PWAP_MDNS_INTERFACES}|${bridge_ifaces}|g" \
        "${PWAP_MDNS_DATADIR}/avahi-daemon.conf.in" >"${tmpfile}" || {
        rm -f "${tmpfile}"
        return 1
    }

    mv "${tmpfile}" "${PWAP_MDNS_RUNDIR}/avahi-daemon.conf" || {
        rm -f "${tmpfile}"
        return 1
    }
}

check_mdns_filter()
{
    iface_flag=$(echo "$1" | head -c1 | tr [:upper:] [:lower:])
    iptables -t filter -C "$1" -p udp --dport 5353 -$iface_flag "$2" -j DROP -m comment --comment "puavo-wlanap-mdns"
}

disable_mdns_filter()
{
    iface_flag=$(echo "$1" | head -c1 | tr [:upper:] [:lower:])
    iptables -t filter -D "$1" -p udp --dport 5353 -$iface_flag "$2" -j DROP -m comment --comment "puavo-wlanap-mdns"
}

enable_mdns_filter()
{
    iface_flag=$(echo "$1" | head -c1 | tr [:upper:] [:lower:])
    iptables -t filter -A "$1" -p udp --dport 5353 -$iface_flag "$2" -j DROP -m comment --comment "puavo-wlanap-mdns" || return $?

    ## Ensure the rule is added only once. If we fail to disable what we
    ## just added, then there is something really strange going on and
    ## we can nothing but return with error.
    disable_mdns_filter "$1" "$2" || return $?
    check_mdns_filter "$1" "$2" 2>/dev/null || {
        iptables -t filter -A "$1" -p udp --dport 5353 -$iface_flag "$2" -j DROP -m comment --comment "puavo-wlanap-mdns"
    }
}

add_avahi_iface()
{
    local retval

    enable_mdns_filter INPUT "$1" || return $?
    enable_mdns_filter OUTPUT "$1" || {
        retval=$?
        disable_mdns_filter INPUT "$1"
        return $retval
    }

    write_avahi_conf || {
        retval=$?
        disable_mdns_filter OUTPUT "$1"
        disable_mdns_filter INPUT "$1"
        return $retval
    }

    avahi-daemon -r || {
        retval=$?
        disable_mdns_filter OUTPUT "$1"
        disable_mdns_filter INPUT "$1"
        return $retval
     }
}

del_avahi_iface()
{
    write_avahi_conf
    avahi-daemon -r

    disable_mdns_filter OUTPUT "$1"
    disable_mdns_filter INPUT "$1"
}

source puavo-wlanap-mdns-env
source "${PWAP_MDNS_DATADIR}/config"
source "${PWAP_MDNS_CONFDIR}/config" || true # User has deleted his config file, cool.

parse_args "$@"

if [ ${PWAP_MDNS_ARGS_DAEMON} -ne 0 ]; then
    daemon --noconfig --stderr='daemon.info' --name='puavo-wlanap-mdns' -- puavo-wlanap-mdns
    exit 0
fi

## After this point the process is getting hot and starts taking actions
## which might have persistent side-effects (files, directories,
## bridges, other processes, etc.). The trap is set to ensure that
## everything gets cleaned up properly afterwards.
trap on_exit EXIT

touch "${PWAP_MDNS_STATEDIR}/networkcache"

mkdir -p "${PWAP_MDNS_RUNDIR}"

write_avahi_services

cp "${PWAP_MDNS_DATADIR}/avahi-daemon.conf.in" "${PWAP_MDNS_RUNDIR}/avahi-daemon.conf"

avahi-daemon -f "${PWAP_MDNS_RUNDIR}/avahi-daemon.conf" &

nc -k -l -U "${PWAP_MDNS_RUNDIR}/control.socket" | while read event tap_iface bridge_iface; do
    case "$event" in
        vtun-up)
            add_avahi_iface "${tap_iface}"
            ;;
        vtun-down)
            del_avahi_iface "${tap_iface}"
            ;;
        *)
            echo "received unknown event '${event}'" >&2
            ;;
    esac
done &

## Read cached events.
while read tap_iface bridge_iface; do
    add_avahi_iface "${tap_iface}"
done <"${PWAP_MDNS_STATEDIR}/networkcache"

wait
