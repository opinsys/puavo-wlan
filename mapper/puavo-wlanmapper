#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (C) 2015 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

from __future__ import division
from __future__ import print_function

import collections
import math
import os
import os.path
import shutil
import sys
import tempfile

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import matplotlib.pyplot
import scipy.interpolate
import numpy

LEVELS = range(-95, -20, 5)

_tmpdir = None

def save_heatmap(filepath, img_w, img_h, xs, ys, zs, scale_factor=0.2):
    ## Interpolate z-values throughout the 2D-space using linear radial
    ## basis function.
    rbf = scipy.interpolate.Rbf(xs, ys, zs, function='linear')

    spc_w = img_w * scale_factor
    spc_h = img_h * scale_factor

    spc_xs, spc_ys = [v.flatten() for v in numpy.meshgrid(numpy.linspace(0, img_w - 1, spc_w),
                                                          numpy.linspace(0, img_h - 1, spc_h))]
    array2d = rbf(spc_xs, spc_ys).reshape((spc_h, spc_w))

    matplotlib.pyplot.imsave(filepath, array2d, format='png',
                             vmin=min(LEVELS), vmax=max(LEVELS), cmap='RdYlBu_r')

class View(QGraphicsView):

    ZOOM_FACTOR = 1.1

    def __init__(self, *args):
        QGraphicsView.__init__(self, *args)

    def wheelEvent(self, event):
        if not event.modifiers() & Qt.ControlModifier:
            QGraphicsView.wheelEvent(self, event)
        else:
            self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

            if event.delta() > 0:
                self.scale(View.ZOOM_FACTOR, View.ZOOM_FACTOR)
            else:
                self.scale(1 / View.ZOOM_FACTOR, 1 / View.ZOOM_FACTOR)

            event.accept()

class Scene(QGraphicsScene):

    heatmapsAdded = pyqtSignal(QStringList)

    def __init__(self, monitor, *args):
        QGraphicsScene.__init__(self, *args)

        self.__monitor = monitor
        self.__monitor.stopped.connect(self.__stopMeasurement)
        self.__monitor.started.connect(self.__startMeasurement)
        self.__currentSpot = None
        self.__currentSpotMeasurements = {}

        self.__spots = []

        self.__layoutPixmapItem = None

        self.__heatmaps = {}
        self.__currentHeatmap = None

        timeLine = QTimeLine(2500)
        timeLine.setLoopCount(0)

        self.__animation = QGraphicsItemAnimation()
        self.__animation.setTimeLine(timeLine)
        self.__animation.setScaleAt(0.0, 1, 1)
        self.__animation.setScaleAt(0.5, 2, 2)
        self.__animation.setScaleAt(1.0, 1, 1)
        self.__animation.setRotationAt(0.0, 0)
        self.__animation.setRotationAt(0.5, 180)
        self.__animation.setRotationAt(1.0, 360)

    def setCurrentHeatmap(self, heatmapName):
        if self.__currentHeatmap is not None:
            self.__currentHeatmap.setVisible(False)
        self.__currentHeatmap = self.__heatmaps[str(heatmapName)]
        self.__currentHeatmap.setVisible(True)

    def heatmaps(self):
        return self.__heatmaps.keys()

    def setLayoutPixmap(self, pixmap):
        if self.__layoutPixmapItem is not None:
            self.removeItem(self.__layoutPixmapItem)
        self.__layoutPixmapItem = self.addPixmap(pixmap)
        self.__layoutPixmapItem.setZValue(-1)

    def mousePressEvent(self, event):
        QGraphicsScene.mousePressEvent(self, event)
        if not event.isAccepted() and event.button() == Qt.LeftButton and not event.modifiers():
            item = Spot()
            item.setPos(event.scenePos())
            self.addItem(item)
            self.__spots.append(item)
            event.accept()

    def removeSpot(self, spot):
        self.__spots.remove(spot)
        if spot == self.__currentSpot:
            self.toggleSpot(spot)
        self.removeItem(spot)
        self.__updateHeatmaps()

    def __startMeasurement(self):
        self.__animation.setItem(self.__currentSpot)
        self.__animation.timeLine().start()

    def __stopMeasurement(self, isSuccess):
        if self.__animation.timeLine().state() == QTimeLine.Running:
            self.__animation.timeLine().stop()
            self.__animation.setStep(0)

        if isSuccess:
            self.__currentSpot.setBrush(QBrush(QColor("#66ff66")))
            self.__currentSpot.measurement = self.__currentSpotMeasurements

            for beacon in self.__monitor.readBeacons():
                bssidmap = self.__currentSpotMeasurements.setdefault(beacon.freq, {})
                rssi = bssidmap.get(beacon.bssid, beacon.rssi)
                bssidmap[beacon.bssid] = (beacon.rssi + rssi) / 2

            self.toggleSpot(self.__currentSpot)

            self.__updateHeatmaps()

    def toggleSpot(self, spot):
        self.__monitor.stop()

        if self.__currentSpot == spot:
            self.__currentSpot = None
            self.__currentSpotMeasurements = {}
            return

        self.__currentSpot = spot
        self.__currentSpotMeasurements = {}

        self.__monitor.start()

    def __updateHeatmaps(self):

        measurements = self.measurements()

        xs = measurements.pop('x')
        ys = measurements.pop('y')

        for freq, bssidmap in measurements.items():

            oldHeatmapNames = set(self.__heatmaps.keys())

            ## To RBF-interpolate, we need more than 1 measurement point.
            if len(xs) > 1:
                w = self.__layoutPixmapItem.pixmap().width()
                h = self.__layoutPixmapItem.pixmap().height()

                for bssid, zs in bssidmap.items():
                    heatmap_name = "%dHz_%s" % (freq, bssid)
                    heatmap_filepath = os.path.join(_tmpdir, "{}.png".format(heatmap_name))
                    save_heatmap(heatmap_filepath, w, h, xs, ys, zs)

                    pixmap = QPixmap(heatmap_filepath).scaled(w, h)
                    try:
                        self.__heatmaps[heatmap_name].setPixmap(pixmap)
                    except KeyError:
                        heatmap = self.addPixmap(pixmap)
                        heatmap.setVisible(False)
                        heatmap.setZValue(-2)
                        self.__heatmaps[heatmap_name] = heatmap

            newHeatmapNames = list(set(self.__heatmaps.keys()) - oldHeatmapNames)
            if newHeatmapNames:
                self.heatmapsAdded.emit(newHeatmapNames)

    def measurements(self):
        result = collections.OrderedDict()

        xs = result['x'] = []
        ys = result['y'] = []

        bssidsets = {}

        for spot in self.__spots:

            if spot.measurement is None:
                continue

            xs.append(int(spot.pos().x()))
            ys.append(int(spot.pos().y()))

            for freq, bssids in spot.measurement.items():
                bssidset = bssidsets.setdefault(freq, set())
                for bssid in bssids:
                    bssidset.add(bssid)

        for spot in self.__spots:

            if spot.measurement is None:
                continue

            for freq, bssidset in bssidsets.items():
                bssidmap = result.setdefault(freq, {})
                for bssid in bssidset:
                    values = bssidmap.setdefault(bssid, [])
                    value = spot.measurement.get(freq, {}).get(bssid, min(LEVELS))
                    values.append(int(round(value)))

        return result

class Spot(QGraphicsPolygonItem):

    SIZE = 30

    def __init__(self):
        QGraphicsPolygonItem.__init__(self)

        points = []
        for i in range(5):
            point = QPointF(0.5 + 0.5 * math.cos(4 / 5 * math.pi * i),
                            0.5 + 0.5 * math.sin(4 / 5 * math.pi * i))
            points.append(point * Spot.SIZE)

        self.setPolygon(QPolygonF(points).translated(-Spot.SIZE / 2,
                                                     -Spot.SIZE / 2))
        self.setFillRule(Qt.WindingFill)

        dropShadowEffect = QGraphicsDropShadowEffect()
        dropShadowEffect.setOffset(2)
        self.setGraphicsEffect(dropShadowEffect)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setBrush(QBrush(QColor("beige")))

        self.setAcceptHoverEvents(True)

        self.measurement = None

        self.__removeAction = QAction("&Remove", None)
        self.__removeAction.triggered.connect(self.__remove)

        self.__toggleAction = QAction("&Toggle measurement", None)
        self.__toggleAction.triggered.connect(self.__toggle)

        self.__contextMenu = QMenu()
        self.__contextMenu.addAction(self.__removeAction)
        self.__contextMenu.addAction(self.__toggleAction)

    def __toggle(self):
        self.scene().toggleSpot(self)

    def __remove(self):
        self.scene().removeSpot(self)

    def hoverEnterEvent(self, event):
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def mouseDoubleClickEvent(self, event):
        self.__toggle()
        event.accept()

    def contextMenuEvent(self, event):
        self.__contextMenu.exec_(event.screenPos())

def get_dot11_interfaces():
    result = []
    for iface in os.listdir('/sys/class/net'):
        if os.path.exists(os.path.join('/sys/class/net/', iface, 'phy80211')):
            result.append(iface)
    return result

Beacon = collections.namedtuple('Beacon', ['rssi', 'bssid', 'freq', 'ssid'])

class Monitor(QObject):

    MIN_CHANNEL_DWELL_TIME = 100
    MAX_CHANNEL_DWELL_TIME = 5000

    started = pyqtSignal()
    stopped = pyqtSignal(bool)

    def __init__(self, interface, *args):
        QObject.__init__(self, *args)

        self.__iface = interface

        self.__process = None
        self.__horst_outfile_path = os.path.join(_tmpdir, 'horst.out')
        self.__horst_configfile_path = os.path.join(_tmpdir, 'horst.conf')

        self.setChannelDwellTime(1100)

    def channelDwellTime(self):
        return self.__dwell

    def setChannelDwellTime(self, millisecs):
        self.__dwell = max(Monitor.MIN_CHANNEL_DWELL_TIME,
                           min(millisecs, Monitor.MAX_CHANNEL_DWELL_TIME))

    def interface(self):
        return self.__iface

    def setInterface(self, interface):
        self.__iface = interface

    def start(self):
        if self.__process is not None:
            return False

        if QProcess.execute('/sbin/ifconfig', [self.__iface, 'down']) != 0:
            return False

        if QProcess.execute('/sbin/iwconfig', [self.__iface, 'mode', 'monitor']) != 0:
            return False

        if QProcess.execute('/sbin/ifconfig', [self.__iface, 'up']) != 0:
            return False

        self.__process = QProcess(self)
        self.__process.setProcessChannelMode(QProcess.ForwardedChannels)

        self.__process.started.connect(self.started)
        self.__process.finished.connect(self.__emit_stopped)

        with open(self.__horst_configfile_path, 'w') as f:
            f.write('quiet\n')
            f.write('interface = {}\n'.format(self.__iface))
            f.write('filter_packet = BEACON\n')
            f.write('channel_upper = 48\n')
            f.write('channel_dwell = {}\n'.format(self.__dwell))
            f.write('channel_scan\n')
            f.write('channel_scan_rounds = 1\n')
            f.write('outfile = {}\n'.format(self.__horst_outfile_path))

        args = ['-c', self.__horst_configfile_path]

        self.__process.start('/usr/sbin/horst', args, QIODevice.ReadOnly)

        return True

    def __emit_stopped(self, exitCode, exitStatus):
        if exitStatus == QProcess.CrashExit:
            self.stopped.emit(False)
        else:
            self.stopped.emit(not bool(exitCode))

    def stop(self):
        if self.__process:
            self.__process.close()
            self.__process = None

    def readBeacons(self):
        result = []

        with open(self.__horst_outfile_path) as f:
            for line in f:
                fields = [s.strip() for s in line.strip().split(',')]
                bssid = fields[1]
                rssi = fields[5]
                freq = fields[10]
                ssid = fields[12]

                result.append(Beacon(rssi=int(rssi), bssid=bssid,
                                     freq=int(freq), ssid=ssid))

        return result

class MonitorWidget(QWidget):

    def __init__(self, monitor, *args):
        QWidget.__init__(self, *args)

        self.__monitor = monitor
        self.__monitor.started.connect(self.__disable)
        self.__monitor.stopped.connect(self.__enable)

        layout = QFormLayout()

        self.__ifaceComboBox = QComboBox()
        self.__ifaceComboBox.addItems(sorted(INTERFACES))
        self.__ifaceComboBox.setCurrentIndex(len(INTERFACES) - 1)
        self.__ifaceComboBox.activated.connect(self.__saveInterface)
        layout.addRow("Interface:", self.__ifaceComboBox)

        self.__dwellSpinBox = QSpinBox()
        self.__dwellSpinBox.setSuffix("ms")
        self.__dwellSpinBox.setMinimum(Monitor.MIN_CHANNEL_DWELL_TIME)
        self.__dwellSpinBox.setMaximum(Monitor.MAX_CHANNEL_DWELL_TIME)
        self.__dwellSpinBox.setSingleStep(10)
        self.__dwellSpinBox.setValue(monitor.channelDwellTime())
        self.__dwellSpinBox.valueChanged.connect(self.__saveDwell)

        dwellWhatsThis = """
        <p>

        <i>Channel dwell time</i> defines the time (in milliseconds) the
        monitor stays on one channel while it is measuring and hopping channels.

        </p>

        <p>

        The longer the dwell time the more complete the set of found BSS IDs,
        because the monitor has more chances to hear beacons. To maximize the
        chances of hearing beacons from all surrounding APs, the channel dwell
        time should be set a bit higher than the shortest expected beacon
        interval. In practice, 1100ms should be enough.

        </p>"""

        self.__dwellSpinBox.setWhatsThis(dwellWhatsThis)
        dwellLabel = QLabel("Channel dwell time:")
        dwellLabel.setWhatsThis(dwellWhatsThis)
        layout.addRow(dwellLabel, self.__dwellSpinBox)

        self.setLayout(layout)

    def __disable(self):
        self.setEnabled(False)

    def __enable(self):
        self.setEnabled(True)

    def __saveInterface(self):
        self.__monitor.setInterface(self.__ifaceComboBox.currentText())

    def __saveDwell(self, value):
        self.__monitor.setChannelDwellTime(value)

class MainWindow(QMainWindow):

    def __init__(self, monitor, *args):
        QMainWindow.__init__(self, *args)

        self.__monitor = monitor

        self.__view = View(self)
        self.__view.setRenderHints(QPainter.Antialiasing)
        self.__scene = None

        self.setWindowTitle("Puavo WLAN Mapper")

        self.setCentralWidget(self.__view)

        self.__setupDockWidgets()
        self.__setupActions()
        self.__setupMenus()

    def closeEvent(self, event):
        self.__monitor.stop()

    def sizeHint(self):
        return QSize(800, 600)

    def __setupActions(self):
        self.__aboutAction = QAction(self)
        self.__aboutAction.setText("&About...")
        self.__aboutAction.triggered.connect(self.__showAboutDialog)

        self.__newSceneAction = QAction(self)
        self.__newSceneAction.setText("&New scene...")
        self.__newSceneAction.setShortcut(QKeySequence("Ctrl+N"))
        self.__newSceneAction.triggered.connect(self.__newSceneDialog)

        self.__exportAction = QAction(self)
        self.__exportAction.setText("&Export measurements...")
        self.__exportAction.triggered.connect(self.__exportMeasurementsWithDialog)

        self.__quitAction = QAction(self)
        self.__quitAction.setText("&Quit")
        self.__quitAction.setShortcut(QKeySequence("Ctrl+Q"))
        self.__quitAction.triggered.connect(self.close)

        self.__whatsThisAction = QWhatsThis.createAction()

    def __setupMenus(self):
        menuBar = QMenuBar()

        fileMenu = menuBar.addMenu("&File")
        fileMenu.addAction(self.__newSceneAction)
        fileMenu.addAction(self.__exportAction)
        fileMenu.addSeparator()
        fileMenu.addAction(self.__quitAction)

        viewMenu = menuBar.addMenu("&View")
        viewMenu.addAction(self.__monitorDockWidget.toggleViewAction())

        helpMenu = menuBar.addMenu("&Help")
        helpMenu.addAction(self.__whatsThisAction)
        helpMenu.addAction(self.__aboutAction)

        self.setMenuBar(menuBar)

    def __setupDockWidgets(self):
        self.__monitorDockWidget = QDockWidget(self)
        self.__monitorWidget = MonitorWidget(self.__monitor, self)
        self.__monitorDockWidget.setWidget(self.__monitorWidget)
        self.__monitorDockWidget.setWindowTitle("Monitor")
        self.addDockWidget(Qt.LeftDockWidgetArea, self.__monitorDockWidget)

        self.__sceneDockWidget = QDockWidget(self)
        self.__sceneWidget = SceneWidget(self)
        self.__sceneDockWidget.setWidget(self.__sceneWidget)
        self.__sceneDockWidget.setWindowTitle("Scene")
        self.addDockWidget(Qt.LeftDockWidgetArea, self.__sceneDockWidget)

    def __exportMeasurementsWithDialog(self):
        filepath = QFileDialog.getSaveFileName(self,
                                               "Export measurements",
                                               QDir.currentPath(),
                                               "CSV (*.csv)")
        if not filepath:
            return

        self.__exportMeasurements(filepath)

    def __exportMeasurements(self, filepath):
        measurements = self.__scene.measurements()

        with open(filepath, "w") as csvfile:
            header = ",".join(measurements.keys())
            csvfile.write("%s\n" % header)
            for vals in zip(*measurements.values()):
                line = ",".join(['{}'.format(v) for v in vals])
                csvfile.write('{}\n'.format(line))

    def __newSceneDialog(self):
        sceneDialog = SceneDialog()
        if not sceneDialog.exec_():
            return

        filepath = sceneDialog.layoutImageFilePath()

        layoutPixmap = QPixmap(filepath, "png")
        if layoutPixmap.isNull():
            msg = "File {} could not be loaded as a layout image.\n\n" \
                  "Please ensure the layout image is a valid PNG file."
            QMessageBox.critical(self, "Failed to load a layout image",
                                 msg.format(filepath))
        else:
            self.__scene = Scene(self.__monitor)
            self.__view.setScene(self.__scene)
            self.__sceneWidget.setScene(self.__scene)
            self.__monitor.stop()
            self.__scene.setLayoutPixmap(layoutPixmap)

    def __showAboutDialog(self):
        aboutText = QString.fromUtf8(
            "<h1>Puavo WLAN Mapper</h1>"
            "<p>Version 0.1.0</p>"
            "<p>Copyright © 2015 <a href=\"http://opinsys.fi\">Opinsys Oy</a></p>"
            "<p>This program is free software: you can redistribute it and/or "
            "modify it under the terms of the GNU General Public License as "
            "published by the Free Software Foundation, either version 2 of the "
            "License, or (at your option) any later version.</p>"
            "<p>This program is distributed in the hope that it will be useful, but"
            " WITHOUT ANY WARRANTY; without even the implied warranty of "
            "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>"
            "<p>See the <a href=\"https://www.gnu.org/licenses/gpl-2.0.html\">GNU "
            "General Public License</a> for more details.</p>")

        QMessageBox.about(self, "About Puavo WLAN Mapper", aboutText)

class SceneDialog(QDialog):

    def __init__(self, *args):
        QDialog.__init__(self, *args)

        self.setModal(True)
        self.setWindowTitle("Create new scene")

        imageLineEdit = QLineEdit()
        imageLineEdit.textChanged.connect(self.__checkImageFilePath)
        browseButton = QPushButton("&Browse")
        browseButton.clicked.connect(self.__getLayoutImageFileName)

        cancelButton = QPushButton("&Cancel")
        cancelButton.clicked.connect(self.reject)
        createButton = QPushButton("Create")
        createButton.clicked.connect(self.accept)
        createButton.setEnabled(False)

        layout = QVBoxLayout(self)
        formLayout = QFormLayout()
        browseLayout = QHBoxLayout()
        buttonLayout = QHBoxLayout()

        browseLayout.addWidget(imageLineEdit)
        browseLayout.addWidget(browseButton)

        formLayout.addRow("Layout image:", browseLayout)

        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(createButton)

        layout.addLayout(formLayout)
        layout.addLayout(buttonLayout)

        self.__imageLineEdit = imageLineEdit
        self.__createButton = createButton

    def layoutImageFilePath(self):
        return self.__imageLineEdit.text()

    def __checkImageFilePath(self):
        self.__createButton.setEnabled(os.path.isfile(self.__imageLineEdit.text()))

    def __getLayoutImageFileName(self):
        filepath = QFileDialog.getOpenFileName(None,
                                               "Load layout image",
                                               QDir.currentPath(),
                                               "Images (*.png)")
        if filepath:
            self.__imageLineEdit.setText(filepath)

    def sizeHint(self):
        s = QDialog.sizeHint(self)
        return QSize(s.width() + self.__imageLineEdit.sizeHint().width() * 2, s.height())

class SceneWidget(QWidget):

    def __init__(self, *args):
        QWidget.__init__(self, *args)

        self.__scene = None

        self.setEnabled(False)

        self.__heatmapListWidget = QListWidget()
        self.__heatmapListWidget.setSortingEnabled(True)
        self.__heatmapListWidget.sortItems(Qt.DescendingOrder)

        layout = QFormLayout(self)
        layout.addRow("Heatmap:", self.__heatmapListWidget)

    def setScene(self, scene):
        if scene is self.__scene:
            return

        self.setEnabled(scene is not None)

        if self.__scene is not None:
            self.__scene.heatmapsAdded.disconnect(self.__addHeatmaps)
            self.__heatmapListWidget.currentTextChanged.disconnect(self.__scene.setCurrentHeatmap)
            self.__heatmapListWidget.clear()

        self.__scene = scene

        if self.__scene is None:
            return

        self.__scene.heatmapsAdded.connect(self.__addHeatmaps)
        self.__heatmapListWidget.currentTextChanged.connect(self.__scene.setCurrentHeatmap)
        self.__addHeatmaps(self.__scene.heatmaps())

    def __addHeatmaps(self, heatmaps):
        self.__heatmapListWidget.addItems(heatmaps)
        if self.__heatmapListWidget.currentRow() == -1 and self.__heatmapListWidget.count() > 0:
            self.__heatmapListWidget.setCurrentRow(0)

INTERFACES = get_dot11_interfaces()

def main():
    app = QApplication(sys.argv)

    if app.argc() > 1:
        error_message = "ERROR: invalid number of arguments ({})"
        print(error_message.format(app.argc() - 1), file=sys.stderr)
        print("Usage: {}".format(sys.argv[0]), file=sys.stderr)
        return 1

    if not INTERFACES:
        QMessageBox.critical(None, "Startup failure", "Failed to find any 802.11 devices.")
        sys.exit(1)

    monitor = Monitor(INTERFACES[0])

    win = MainWindow(monitor)
    win.show()

    return app.exec_()

if __name__ == "__main__":
    try:
        _tmpdir = tempfile.mkdtemp(prefix='puavo-wlanmapper.')
        sys.exit(main())
    finally:
        if _tmpdir:
            shutil.rmtree(_tmpdir)
