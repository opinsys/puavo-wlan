#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (C) 2015 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

from __future__ import division
from __future__ import print_function

import collections
import errno
import math
import os
import os.path
import pickle
import shutil
import sys
import tarfile
import tempfile

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import matplotlib.pyplot
import scipy.interpolate
import numpy

LEVELS = range(-95, -20, 5)

_tmpdir = None

FREQS = [2412 + i * 5 for i in range(13)] + [2484] + [5180, 5200, 5220, 5240]
CHANS = range(1, 15) + [36, 40, 44, 48]

FREQ_TO_CHAN = dict(zip(FREQS, CHANS))

def save_heatmap(filepath, img_w, img_h, xs, ys, zs, scale_factor=0.2):
    ## Interpolate z-values throughout the 2D-space using linear radial
    ## basis function.
    rbf = scipy.interpolate.Rbf(xs, ys, zs, function='linear')

    spc_w = img_w * scale_factor
    spc_h = img_h * scale_factor

    spc_xs, spc_ys = [v.flatten() for v in numpy.meshgrid(numpy.linspace(0, img_w - 1, spc_w),
                                                          numpy.linspace(0, img_h - 1, spc_h))]
    array2d = rbf(spc_xs, spc_ys).reshape((spc_h, spc_w))

    matplotlib.pyplot.imsave(filepath, array2d, format='png',
                             vmin=min(LEVELS), vmax=max(LEVELS), cmap='RdYlBu_r')

class View(QGraphicsView):

    ZOOM_FACTOR = 1.1

    def __init__(self, *args):
        QGraphicsView.__init__(self, *args)

    def wheelEvent(self, event):
        if not event.modifiers() & Qt.ControlModifier:
            QGraphicsView.wheelEvent(self, event)
        else:
            self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

            if event.delta() > 0:
                self.scale(View.ZOOM_FACTOR, View.ZOOM_FACTOR)
            else:
                self.scale(1 / View.ZOOM_FACTOR, 1 / View.ZOOM_FACTOR)

            event.accept()

class Scene(QGraphicsScene):

    heatmapsAdded = pyqtSignal(QStringList)

    def __init__(self, monitor, layoutPixmap=None):
        QGraphicsScene.__init__(self)

        self.__monitor = monitor
        self.__monitor.started.connect(self.__startAnimation)
        self.__monitor.stopped.connect(self.__stopAnimation)
        self.__monitor.stopped.connect(self.__measurementStopped)
        self.__currentSpot = None
        self.__currentSpotMeasurements = {}

        self.__spots = []
        self.essids = {}

        if layoutPixmap is None:
            layoutPixmap = QPixmap()
        self.__layoutPixmapItem = self.addPixmap(layoutPixmap)
        self.__layoutPixmapItem.setZValue(-1)

        self.__heatmaps = {}
        self.__currentHeatmap = None

        timeLine = QTimeLine(2500)
        timeLine.setLoopCount(0)

        self.__animation = QGraphicsItemAnimation()
        self.__animation.setTimeLine(timeLine)
        self.__animation.setScaleAt(0.0, 1, 1)
        self.__animation.setScaleAt(0.5, 2, 2)
        self.__animation.setScaleAt(1.0, 1, 1)
        self.__animation.setRotationAt(0.0, 0)
        self.__animation.setRotationAt(0.5, 180)
        self.__animation.setRotationAt(1.0, 360)

    def saveAs(self, filepath):
        scenedir = os.path.join(_tmpdir, "scene")
        try:
            shutil.rmtree(scenedir)
        except OSError, e:
            if e.errno != errno.ENOENT:
                raise e
        os.mkdir(scenedir)

        for heatmap_name, heatmap_item in self.__heatmaps.items():
            shutil.copy(os.path.join(_tmpdir, "{}.png".format(heatmap_name)),
                        scenedir)

        data = []
        for spot in self.__spots:
            data.append({
                'x': spot.x(),
                'y': spot.y(),
                'measurement': spot.measurement,
            })
        with open(os.path.join(scenedir, "spots.pickle"), "w") as f:
            pickle.dump(data, f)

        with open(os.path.join(scenedir, "essids.pickle"), "w") as f:
            pickle.dump(self.essids, f)

        shutil.copy(os.path.join(_tmpdir, "layout.png"), scenedir)

        with tarfile.open(unicode(filepath), "w:gz") as f:
            f.add(scenedir, "scene")

    def open(self, filepath):
        with tarfile.open(unicode(filepath), "r:gz") as archive_file:

            src_image = archive_file.extractfile("scene/layout.png")
            with open(os.path.join(_tmpdir, "layout.png"), "wb") as dst_image:
                shutil.copyfileobj(src_image, dst_image)
            self.__layoutPixmapItem.setPixmap(QPixmap(os.path.join(_tmpdir, "layout.png")))

            essids_picklefile = archive_file.extractfile("scene/essids.pickle")
            self.essids = pickle.load(essids_picklefile)

            spots_picklefile = archive_file.extractfile("scene/spots.pickle")
            spots_data = pickle.load(spots_picklefile)
            for spot_data in spots_data:
                x = spot_data['x']
                y = spot_data['y']
                measurement = spot_data['measurement']
                item = self.__addSpot(QPointF(x, y))
                item.measurement = measurement

            self.__updateHeatmaps()

    def setCurrentHeatmap(self, heatmapName):
        if self.__currentHeatmap is not None:
            self.__currentHeatmap.setVisible(False)
        self.__currentHeatmap = self.__heatmaps[str(heatmapName)]
        self.__currentHeatmap.setVisible(True)

    def heatmapNames(self):
        return self.__heatmaps.keys()

    def __addSpot(self, pos):
        item = Spot()
        item.setPos(pos)
        self.addItem(item)
        self.__spots.append(item)
        return item

    def mousePressEvent(self, event):
        QGraphicsScene.mousePressEvent(self, event)
        if not event.isAccepted() and event.button() == Qt.LeftButton and not event.modifiers():
            self.__addSpot(event.scenePos())
            event.accept()

    def removeSpot(self, spot):
        self.__spots.remove(spot)
        if spot == self.__currentSpot:
            self.toggleSpot(spot)
        self.removeItem(spot)
        self.__updateHeatmaps()

    def __startAnimation(self):
        self.__animation.setItem(self.__currentSpot)
        self.__animation.timeLine().start()

    def __stopAnimation(self):
        self.__animation.timeLine().stop()
        self.__animation.setStep(0)

    def __measurementStopped(self, isSuccess):
        if isSuccess:
            self.__currentSpot.measurement = self.__currentSpotMeasurements

            for beacon in self.__monitor.readBeacons():
                bssidmap = self.__currentSpotMeasurements.setdefault(beacon.freq, {})
                rssi = bssidmap.get(beacon.bssid, beacon.rssi)
                bssidmap[beacon.bssid] = (beacon.rssi + rssi) / 2
                self.essids[beacon.bssid] = beacon.ssid

            self.toggleSpot(self.__currentSpot)

            self.__updateHeatmaps()

    def toggleSpot(self, spot):
        self.__monitor.stop()

        if self.__currentSpot == spot:
            self.__currentSpot = None
            self.__currentSpotMeasurements = {}
            return

        self.__currentSpot = spot
        self.__currentSpotMeasurements = {}

        self.__monitor.start()

    def __updateHeatmaps(self):
        measurements = self.measurements()

        xs = measurements.pop('x')
        ys = measurements.pop('y')

        width = self.__layoutPixmapItem.pixmap().width()
        height = self.__layoutPixmapItem.pixmap().height()

        for freq, bssidmap in measurements.items():

            oldHeatmapNames = set(self.__heatmaps.keys())

            ## To RBF-interpolate, we need more than 1 measurement point.
            if len(xs) > 1:

                for bssid, zs in bssidmap.items():
                    heatmap_name = "%dHz_%s" % (freq, bssid)
                    heatmap_filepath = os.path.join(_tmpdir, "{}.png".format(heatmap_name))
                    save_heatmap(heatmap_filepath, width, height, xs, ys, zs)

                    pixmap = QPixmap(heatmap_filepath).scaled(width, height)
                    try:
                        self.__heatmaps[heatmap_name].setPixmap(pixmap)
                    except KeyError:
                        heatmap = self.addPixmap(pixmap)
                        heatmap.setVisible(False)
                        heatmap.setZValue(-2)
                        self.__heatmaps[heatmap_name] = heatmap

            newHeatmapNames = list(set(self.__heatmaps.keys()) - oldHeatmapNames)
            if newHeatmapNames:
                self.heatmapsAdded.emit(newHeatmapNames)

    def measurements(self):
        result = collections.OrderedDict()

        xs = result['x'] = []
        ys = result['y'] = []

        bssidsets = {}

        for spot in self.__spots:

            if spot.measurement is None:
                continue

            xs.append(int(spot.pos().x()))
            ys.append(int(spot.pos().y()))

            for freq, bssids in spot.measurement.items():
                bssidset = bssidsets.setdefault(freq, set())
                for bssid in bssids:
                    bssidset.add(bssid)

        for spot in self.__spots:

            if spot.measurement is None:
                continue

            for freq, bssidset in bssidsets.items():
                bssidmap = result.setdefault(freq, {})
                for bssid in bssidset:
                    values = bssidmap.setdefault(bssid, [])
                    value = spot.measurement.get(freq, {}).get(bssid, min(LEVELS))
                    values.append(int(round(value)))

        return result

class Spot(QGraphicsPolygonItem):

    SIZE = 30

    def __init__(self):
        QGraphicsPolygonItem.__init__(self)

        points = []
        for i in range(5):
            point = QPointF(0.5 + 0.5 * math.cos(4 / 5 * math.pi * i),
                            0.5 + 0.5 * math.sin(4 / 5 * math.pi * i))
            points.append(point * Spot.SIZE)

        self.setPolygon(QPolygonF(points).translated(-Spot.SIZE / 2,
                                                     -Spot.SIZE / 2))
        self.setFillRule(Qt.WindingFill)

        dropShadowEffect = QGraphicsDropShadowEffect()
        dropShadowEffect.setOffset(2)
        self.setGraphicsEffect(dropShadowEffect)
        self.setFlag(QGraphicsItem.ItemIsMovable)

        self.setAcceptHoverEvents(True)

        self.measurement = None

        self.__removeAction = QAction("&Remove", None)
        self.__removeAction.triggered.connect(self.__remove)

        self.__toggleAction = QAction("&Toggle measurement", None)
        self.__toggleAction.triggered.connect(self.__toggle)

        self.__contextMenu = QMenu()
        self.__contextMenu.addAction(self.__removeAction)
        self.__contextMenu.addAction(self.__toggleAction)

    def __toggle(self):
        self.scene().toggleSpot(self)

    def __remove(self):
        self.scene().removeSpot(self)

    def hoverEnterEvent(self, event):
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def mouseDoubleClickEvent(self, event):
        self.__toggle()
        event.accept()

    def contextMenuEvent(self, event):
        self.__contextMenu.exec_(event.screenPos())

    @property
    def measurement(self):
        return self.__measurement

    @measurement.setter
    def measurement(self, measurement):
        if measurement is None:
            self.setBrush(QBrush(QColor("beige")))
        else:
            self.setBrush(QBrush(QColor("#66ff66")))
        self.__measurement = measurement

def get_dot11_interfaces():
    result = []
    for iface in os.listdir('/sys/class/net'):
        if os.path.exists(os.path.join('/sys/class/net/', iface, 'phy80211')):
            result.append(iface)
    return result

Beacon = collections.namedtuple('Beacon', ['rssi', 'bssid', 'freq', 'ssid'])

class Monitor(QObject):

    MIN_CHANNEL_DWELL_TIME = 100
    MAX_CHANNEL_DWELL_TIME = 5000

    started = pyqtSignal()
    stopped = pyqtSignal(bool)

    def __init__(self, interface, *args):
        QObject.__init__(self, *args)

        self.__iface = interface

        self.__process = None
        self.__horst_outfile_path = os.path.join(_tmpdir, 'horst.out')
        self.__horst_configfile_path = os.path.join(_tmpdir, 'horst.conf')

        self.setChannelDwellTime(500)

    def channelDwellTime(self):
        return self.__dwell

    def setChannelDwellTime(self, millisecs):
        self.__dwell = max(Monitor.MIN_CHANNEL_DWELL_TIME,
                           min(millisecs, Monitor.MAX_CHANNEL_DWELL_TIME))

    def interface(self):
        return self.__iface

    def setInterface(self, interface):
        self.__iface = interface

    def start(self):
        if self.__process is not None:
            return False

        self.__process = QProcess(self)
        self.__process.setProcessChannelMode(QProcess.ForwardedChannels)

        self.__process.started.connect(self.started)
        self.__process.finished.connect(self.__emit_stopped)

        with open(self.__horst_configfile_path, 'w') as f:
            f.write('quiet\n')
            f.write('interface = {}\n'.format(self.__iface))
            f.write('filter_packet = BEACON\n')
            f.write('channel_upper = 48\n')
            f.write('channel_dwell = {}\n'.format(self.__dwell))
            f.write('channel = 1\n')
            f.write('channel_scan\n')
            f.write('channel_scan_rounds = 1\n')
            f.write('outfile = {}\n'.format(self.__horst_outfile_path))

        args = ['-c', self.__horst_configfile_path]

        self.__process.start("%s-horst" % os.path.abspath(__file__), args,
                             QIODevice.ReadOnly)

        return True

    def __emit_stopped(self, exitCode, exitStatus):
        if exitStatus == QProcess.CrashExit:
            self.stopped.emit(False)
        else:
            self.stopped.emit(not bool(exitCode))

    def stop(self):
        if self.__process:
            self.__process.close()
            self.__process = None

    def readBeacons(self):
        result = []

        with open(self.__horst_outfile_path) as f:
            f.readline() # Ignore header
            for line in f:
                fields = [s.strip() for s in line.strip().split(',')]
                bssid = fields[4]
                rssi = fields[6]
                freq = fields[9]
                ssid = fields[11]

                result.append(Beacon(rssi=int(rssi), bssid=bssid,
                                     freq=int(freq), ssid=ssid))

        return result

class MonitorWidget(QWidget):

    def __init__(self, monitor, *args):
        QWidget.__init__(self, *args)

        self.__monitor = monitor
        self.__monitor.started.connect(self.__disable)
        self.__monitor.stopped.connect(self.__enable)

        layout = QFormLayout()

        self.__ifaceComboBox = QComboBox()
        self.__ifaceComboBox.addItems(sorted(INTERFACES))
        self.__ifaceComboBox.setCurrentIndex(len(INTERFACES) - 1)
        self.__ifaceComboBox.activated.connect(self.__saveInterface)
        layout.addRow("Interface:", self.__ifaceComboBox)

        self.__dwellSpinBox = QSpinBox()
        self.__dwellSpinBox.setSuffix("ms")
        self.__dwellSpinBox.setMinimum(Monitor.MIN_CHANNEL_DWELL_TIME)
        self.__dwellSpinBox.setMaximum(Monitor.MAX_CHANNEL_DWELL_TIME)
        self.__dwellSpinBox.setSingleStep(50)
        self.__dwellSpinBox.setValue(monitor.channelDwellTime())
        self.__dwellSpinBox.valueChanged.connect(self.__saveDwell)

        dwellWhatsThis = """
        <p>

        <i>Channel dwell time</i> defines the time (in milliseconds) the
        monitor stays on one channel while it is measuring and hopping channels.

        </p>

        <p>

        The longer the dwell time the more complete the set of found BSS IDs,
        because the monitor has more chances to hear beacons. To maximize the
        chances of hearing beacons from all surrounding APs, the channel dwell
        time should be set a bit higher than the shortest expected beacon
        interval.

        </p>"""

        self.__dwellSpinBox.setWhatsThis(dwellWhatsThis)
        dwellLabel = QLabel("Channel dwell time:")
        dwellLabel.setWhatsThis(dwellWhatsThis)
        layout.addRow(dwellLabel, self.__dwellSpinBox)

        self.setLayout(layout)

    def __disable(self):
        self.setEnabled(False)

    def __enable(self):
        self.setEnabled(True)

    def __saveInterface(self):
        self.__monitor.setInterface(self.__ifaceComboBox.currentText())

    def __saveDwell(self, value):
        self.__monitor.setChannelDwellTime(value)

class MainWindow(QMainWindow):

    def __init__(self, monitor, *args):
        QMainWindow.__init__(self, *args)

        self.__monitor = monitor

        self.__view = View(self)
        self.__view.setRenderHints(QPainter.Antialiasing)
        self.__scene = None

        self.setWindowTitle("Puavo WLAN Mapper")

        self.setCentralWidget(self.__view)

        self.__setupDockWidgets()
        self.__setupActions()
        self.__setupMenus()

    def closeEvent(self, event):
        self.__monitor.stop()

    def sizeHint(self):
        return QSize(800, 600)

    def __setupActions(self):
        self.__aboutAction = QAction(self)
        self.__aboutAction.setText("&About...")
        self.__aboutAction.triggered.connect(self.__showAboutDialog)

        self.__newSceneAction = QAction(self)
        self.__newSceneAction.setText("&New scene...")
        self.__newSceneAction.setShortcut(QKeySequence("Ctrl+N"))
        self.__newSceneAction.triggered.connect(self.__newSceneDialog)

        self.__saveSceneAsAction = QAction(self)
        self.__saveSceneAsAction.setText("&Save scene as...")
        self.__saveSceneAsAction.setShortcut(QKeySequence("Ctrl+S"))
        self.__saveSceneAsAction.triggered.connect(self.__saveSceneAsDialog)
        self.__saveSceneAsAction.setEnabled(False)

        self.__openSceneAction = QAction(self)
        self.__openSceneAction.setText("&Open scene...")
        self.__openSceneAction.setShortcut(QKeySequence("Ctrl+O"))
        self.__openSceneAction.triggered.connect(self.__openSceneDialog)

        self.__quitAction = QAction(self)
        self.__quitAction.setText("&Quit")
        self.__quitAction.setShortcut(QKeySequence("Ctrl+Q"))
        self.__quitAction.triggered.connect(self.close)

        self.__whatsThisAction = QWhatsThis.createAction()

    def __setupMenus(self):
        menuBar = QMenuBar()

        fileMenu = menuBar.addMenu("&File")
        fileMenu.addAction(self.__newSceneAction)
        fileMenu.addAction(self.__openSceneAction)
        fileMenu.addAction(self.__saveSceneAsAction)
        fileMenu.addSeparator()
        fileMenu.addAction(self.__quitAction)

        viewMenu = menuBar.addMenu("&View")
        viewMenu.addAction(self.__monitorDockWidget.toggleViewAction())
        viewMenu.addAction(self.__sceneDockWidget.toggleViewAction())

        helpMenu = menuBar.addMenu("&Help")
        helpMenu.addAction(self.__whatsThisAction)
        helpMenu.addAction(self.__aboutAction)

        self.setMenuBar(menuBar)

    def __setupDockWidgets(self):
        self.__monitorDockWidget = QDockWidget(self)
        self.__monitorWidget = MonitorWidget(self.__monitor, self)
        self.__monitorDockWidget.setWidget(self.__monitorWidget)
        self.__monitorDockWidget.setWindowTitle("Monitor")
        self.addDockWidget(Qt.LeftDockWidgetArea, self.__monitorDockWidget)

        self.__sceneDockWidget = QDockWidget(self)
        self.__sceneWidget = SceneWidget(self)
        self.__sceneDockWidget.setWidget(self.__sceneWidget)
        self.__sceneDockWidget.setWindowTitle("Scene")
        self.addDockWidget(Qt.LeftDockWidgetArea, self.__sceneDockWidget)

    def __openSceneDialog(self):
        filepath = QFileDialog.getOpenFileName(None,
                                               "Open a scene",
                                               QDir.currentPath(),
                                               "Compressed Tar archives (*.tar.gz)")
        if filepath:
            self.__scene = Scene(self.__monitor)
            self.__saveSceneAsAction.setEnabled(True)
            self.__view.setScene(self.__scene)
            self.__sceneWidget.setScene(self.__scene)
            self.__monitor.stop()
            self.__scene.open(filepath)

    def __saveSceneAsDialog(self):
        filepath = QFileDialog.getSaveFileName(None,
                                               "Save the scene as",
                                               QDir.currentPath(),
                                               "Compressed Tar archives (*.tar.gz)")
        if filepath:
            self.__scene.saveAs(filepath)

    def __newSceneDialog(self):
        sceneDialog = SceneDialog()
        if not sceneDialog.exec_():
            return

        filepath = sceneDialog.layoutImageFilePath()

        layoutPixmap = QPixmap(filepath, "png")
        if layoutPixmap.isNull():
            msg = "File {} could not be loaded as a layout image.\n\n" \
                  "Please ensure the layout image is a valid PNG file."
            QMessageBox.critical(self, "Failed to load a layout image",
                                 msg.format(filepath))
        else:
            shutil.copy(filepath, os.path.join(_tmpdir, "layout.png"))
            self.__scene = Scene(self.__monitor, layoutPixmap)
            self.__saveSceneAsAction.setEnabled(True)
            self.__view.setScene(self.__scene)
            self.__sceneWidget.setScene(self.__scene)
            self.__monitor.stop()

    def __showAboutDialog(self):
        aboutText = QString.fromUtf8(
            "<h1>Puavo WLAN Mapper</h1>"
            "<p>Version 0.1.0</p>"
            "<p>Copyright © 2015 <a href=\"http://opinsys.fi\">Opinsys Oy</a></p>"
            "<p>This program is free software: you can redistribute it and/or "
            "modify it under the terms of the GNU General Public License as "
            "published by the Free Software Foundation, either version 2 of the "
            "License, or (at your option) any later version.</p>"
            "<p>This program is distributed in the hope that it will be useful, but"
            " WITHOUT ANY WARRANTY; without even the implied warranty of "
            "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>"
            "<p>See the <a href=\"https://www.gnu.org/licenses/gpl-2.0.html\">GNU "
            "General Public License</a> for more details.</p>")

        QMessageBox.about(self, "About Puavo WLAN Mapper", aboutText)

class SceneDialog(QDialog):

    def __init__(self, *args):
        QDialog.__init__(self, *args)

        self.setModal(True)
        self.setWindowTitle("Create a new scene")

        imageLineEdit = QLineEdit()
        imageLineEdit.textChanged.connect(self.__checkImageFilePath)
        browseButton = QPushButton("&Browse")
        browseButton.clicked.connect(self.__getLayoutImageFileName)

        cancelButton = QPushButton("&Cancel")
        cancelButton.clicked.connect(self.reject)
        createButton = QPushButton("Create")
        createButton.clicked.connect(self.accept)
        createButton.setEnabled(False)

        layout = QVBoxLayout(self)
        formLayout = QFormLayout()
        browseLayout = QHBoxLayout()
        buttonLayout = QHBoxLayout()

        browseLayout.addWidget(imageLineEdit)
        browseLayout.addWidget(browseButton)

        formLayout.addRow("Layout image:", browseLayout)

        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(createButton)

        layout.addLayout(formLayout)
        layout.addLayout(buttonLayout)

        self.__imageLineEdit = imageLineEdit
        self.__createButton = createButton

    def layoutImageFilePath(self):
        return self.__imageLineEdit.text()

    def __checkImageFilePath(self):
        self.__createButton.setEnabled(os.path.isfile(self.__imageLineEdit.text()))

    def __getLayoutImageFileName(self):
        filepath = QFileDialog.getOpenFileName(None,
                                               "Load layout image",
                                               QDir.currentPath(),
                                               "Images (*.png)")
        if filepath:
            self.__imageLineEdit.setText(filepath)

    def sizeHint(self):
        s = QDialog.sizeHint(self)
        return QSize(s.width() + self.__imageLineEdit.sizeHint().width() * 2, s.height())

class SceneWidget(QWidget):

    def __init__(self, *args):
        QWidget.__init__(self, *args)

        self.__scene = None

        self.setEnabled(False)

        self.__freqListWidget = QListWidget()
        self.__freqListWidget.setSortingEnabled(True)
        self.__freqListWidget.sortItems(Qt.AscendingOrder)

        self.__bssidListWidget = QListWidget()
        self.__bssidListWidget.setSortingEnabled(True)
        self.__bssidListWidget.sortItems(Qt.AscendingOrder)

        layout = QFormLayout(self)
        layout.addRow("Frequency:", self.__freqListWidget)
        layout.addRow("BSSID:", self.__bssidListWidget)

    def setScene(self, scene):
        if scene is self.__scene:
            return

        self.setEnabled(scene is not None)

        if self.__scene is not None:
            self.__scene.heatmapsAdded.disconnect(self.__updateFreqList)
            self.__freqListWidget.currentTextChanged.disconnect(self.__setFreq)
            self.__bssidListWidget.currentTextChanged.disconnect(self.__setBSSID)
            self.__freqListWidget.clear()
            self.__bssidListWidget.clear()

        self.__scene = scene

        if self.__scene is None:
            return

        self.__scene.heatmapsAdded.connect(self.__updateFreqList)
        self.__freqListWidget.currentTextChanged.connect(self.__setFreq)
        self.__bssidListWidget.currentTextChanged.connect(self.__setBSSID)
        self.__updateFreqList(self.__scene.heatmapNames())

    def __updateFreqList(self, heatmapNames):
        freqs = set()
        for i in range(self.__freqListWidget.count()):
            freqs.add(str(self.__freqListWidget.item(i).text()).split()[0])

        for heatmapName in heatmapNames:
            freq, _ = heatmapName.split("Hz_")
            freqs.add(freq)

        items = ["%s (Channel %d)" % (f, FREQ_TO_CHAN[int(f)]) for f in freqs]

        self.__freqListWidget.clear()
        self.__freqListWidget.addItems(items)

        if self.__freqListWidget.currentRow() == -1 and self.__freqListWidget.count() > 0:
            self.__freqListWidget.setCurrentRow(0)

    def __setBSSID(self, bssid_essid):
        if not bssid_essid.isNull():
            freq = str(self.__freqListWidget.currentItem().text()).split()[0]
            bssid = str(bssid_essid).split()[0]
            self.__scene.setCurrentHeatmap("%sHz_%s" % (freq, bssid))

    def __setFreq(self, newFreqChan):
        try:
            newFreq = str(newFreqChan).split()[0]
        except IndexError:
            newFreq = ''
        bssids = set()
        for heatmapName in self.__scene.heatmapNames():
            freq, bssid = heatmapName.split("Hz_")
            if freq == newFreq:
                bssids.add(bssid)

        items = ["%s (%s)" % (b, self.__scene.essids[b]) for b in bssids]

        self.__bssidListWidget.clear()
        self.__bssidListWidget.addItems(items)
        self.__bssidListWidget.setCurrentRow(0)

INTERFACES = get_dot11_interfaces()

def main():
    global _tmpdir
    try:
        _tmpdir = tempfile.mkdtemp(prefix='puavo-wlanmapper.')
        app = QApplication(sys.argv)

        if app.argc() > 1:
            error_message = "ERROR: invalid number of arguments ({})"
            print(error_message.format(app.argc() - 1), file=sys.stderr)
            print("Usage: {}".format(sys.argv[0]), file=sys.stderr)
            return 1

        if not INTERFACES:
            QMessageBox.critical(None, "Startup failure", "Failed to find any 802.11 devices.")
            sys.exit(1)

        monitor = Monitor(INTERFACES[0])

        win = MainWindow(monitor)
        win.show()

        sys.exit(app.exec_())
    finally:
        if _tmpdir:
            shutil.rmtree(_tmpdir)

if __name__ == "__main__":
    main()
