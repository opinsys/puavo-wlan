#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2015 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

from __future__ import division
from __future__ import print_function

import collections
import errno
import math
import os
import os.path
import pickle
import shutil
import sys
import tarfile
import tempfile

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import matplotlib.pyplot
import scipy.interpolate
import numpy

resource_data = b"\
\x00\x00\x06\xc4\
\x89\
\x50\x4e\x47\x0d\x0a\x1a\x0a\x00\x00\x00\x0d\x49\x48\x44\x52\x00\
\x00\x00\x40\x00\x00\x00\x40\x08\x06\x00\x00\x00\xaa\x69\x71\xde\
\x00\x00\x00\x04\x73\x42\x49\x54\x08\x08\x08\x08\x7c\x08\x64\x88\
\x00\x00\x00\x09\x70\x48\x59\x73\x00\x00\x0d\xd7\x00\x00\x0d\xd7\
\x01\x42\x28\x9b\x78\x00\x00\x00\x19\x74\x45\x58\x74\x53\x6f\x66\
\x74\x77\x61\x72\x65\x00\x77\x77\x77\x2e\x69\x6e\x6b\x73\x63\x61\
\x70\x65\x2e\x6f\x72\x67\x9b\xee\x3c\x1a\x00\x00\x06\x41\x49\x44\
\x41\x54\x78\x9c\xdd\x9b\x7f\x88\x55\x45\x14\xc7\x3f\xe7\xed\x5b\
\xc3\x4c\x53\xff\x68\x8d\xdc\xca\x36\x2c\x24\xb0\xc2\xc0\x25\xd0\
\x96\x7e\x60\x60\x9a\x92\x4b\x25\x61\x14\x25\x51\xa2\x7f\x04\x42\
\x25\x14\x0a\x89\x46\x41\x3f\x48\xa2\x96\x36\x4c\xb0\x4c\x63\x5b\
\x50\xfa\x61\x1b\x85\x9a\x15\x56\x54\xd8\x92\x9a\xe5\xea\x66\x16\
\xe1\x0f\x48\x53\x4f\x7f\xcc\x5c\xdf\xbc\xdb\xbd\x6f\xdf\xbb\x77\
\xae\xf7\x6d\x5f\xb8\xec\xbc\x99\xb9\x73\xce\xf9\xce\x99\x1f\x67\
\xe6\xae\xa8\x2a\x69\x20\x22\xd7\x00\xd3\x81\xf1\xc0\x45\xce\xd3\
\x00\xec\x07\xfa\xec\xb3\x07\xd8\x08\x6c\x51\xd5\x53\xa9\x84\x7a\
\x84\x24\x21\x40\x44\xa6\x00\xed\xc0\x0c\xa0\xb9\xc6\xd7\xff\x00\
\xba\x81\x0d\x40\x97\xa6\xed\x81\xb4\x50\xd5\xaa\x1f\xe0\x5a\xe0\
\x03\x40\x3d\x3d\x3b\x80\x69\xb5\xe8\xe0\xfb\xa9\xca\x03\x44\x64\
\x2c\xb0\x02\xb8\x13\x90\x50\xf1\x5f\xc0\x7b\xc0\xc7\xc0\x3e\x4a\
\x2e\x7f\x92\xf2\x21\xd1\x0a\xcc\xb4\xe9\x30\x7a\x80\x85\xaa\xfa\
\xed\x80\xca\xf8\x46\x15\xbd\x7e\x3d\xd0\x4f\x79\xcf\x9d\x00\x5e\
\x05\x6e\x01\x1a\x6b\xf0\x20\x01\xae\x03\x56\x02\x47\x43\x6d\x1e\
\x03\xda\xcf\xb6\x07\x0c\xa4\xf0\xfd\xc0\x71\x47\xc9\xd3\xc0\x5a\
\xe0\xf2\xd4\x82\x61\x0c\xf0\x92\x25\xd3\x25\x62\x19\x76\x6e\xca\
\x95\x00\xe0\xe9\x90\x62\xbf\x03\x37\x78\x57\x00\x26\x00\x3f\x86\
\x64\xad\x03\x1a\x72\x23\xc0\xf6\xbc\xab\xd0\x37\xc0\xa5\x99\x29\
\x01\x23\x81\x4d\x21\x99\x2b\x73\x21\xc0\x8e\x79\xd7\xed\xbb\x80\
\x61\x99\x2b\x62\xf6\x0d\x2f\x84\x48\xb8\x27\x6b\xb9\x65\xab\x80\
\x88\x34\x03\x5f\x00\x4d\x36\x6b\x87\x25\x64\x95\xfd\x0b\xd0\x0b\
\x1c\x8c\x98\x4f\x77\xaa\xea\xf2\x88\x7c\x44\x64\x1e\xd0\x16\x51\
\x34\x1c\x98\x68\xd3\x7b\x81\x9b\x80\x77\x80\x59\x36\xef\x6f\x60\
\xaa\xaa\x6e\x8f\x6a\xd7\x0b\x42\xbd\xb0\x96\x12\xfb\x07\x81\x8b\
\x6d\xfe\x4f\x94\xf7\x4c\xd4\xd3\x53\xa1\x77\x57\x55\xf1\xfe\x11\
\x5b\xf7\x3c\xe0\x3b\x27\xff\x6b\x32\x9c\x14\x0b\x01\x11\x22\x32\
\x09\x98\xe3\x70\xd3\xae\xaa\xbf\x78\xe6\x7b\x40\xa8\xea\x51\xcc\
\x7e\xe1\x98\xcd\x9a\x08\xdc\x9d\x95\xbc\xa2\x93\x5e\x4e\x69\x93\
\xb3\x4e\x55\x7b\x9c\xb2\x5e\xa0\xc5\xa6\x5f\x03\x3e\x8b\x68\xab\
\xbf\x82\x9c\x4e\x60\x5b\x44\x7e\x0b\xf0\x84\x4d\xf7\x05\x99\xaa\
\xba\x4b\x44\x9e\x73\xca\x96\x8a\xc8\xdb\xaa\x7a\xa2\x82\x8c\x64\
\xb0\x6e\x37\x95\x92\xcb\xfd\x03\x8c\x0f\xb9\xf0\xeb\x4e\xf9\xbd\
\x1e\x27\xbe\xc9\x4e\xbb\xdb\x42\x65\x23\x30\x4b\x6f\x50\x3e\x3f\
\xcb\x21\xe0\xba\xfe\x1b\xaa\xda\xeb\x9d\xe9\x1a\xa1\xaa\x87\x31\
\xdb\xef\x00\x73\xe2\xea\xa6\x41\x40\xc0\x0c\x27\x6f\x75\x16\x82\
\x12\x62\x0d\xa6\xf7\x01\xa6\x88\xc8\x48\xdf\x02\x0a\x36\x9e\x0f\
\x42\xda\x3f\x81\x4f\x7d\x0b\x49\x0a\x55\xed\xc3\x2c\xcb\x00\x8d\
\xc0\xad\xbe\x65\x14\x30\x87\x19\x01\xba\x55\xf5\xa4\x6f\x21\x29\
\xf1\xae\x93\x9e\x1e\x5b\x2b\x21\x8a\x98\x93\x9c\x00\x3d\x31\xf5\
\x76\x02\x9f\xd8\x74\xa5\xd9\xbe\x56\x1c\x76\xda\xfd\x21\xa6\x8e\
\xab\xd3\xf8\x98\x3a\xa9\xb0\x99\xd2\x4c\x7b\x73\xd6\x5b\xcf\x04\
\x2b\x45\xb3\xa3\xdf\xfe\x2c\x56\x01\xf7\x80\xa2\x2f\xcc\x4e\x1d\
\xe0\x00\x26\x0c\x07\x68\x12\x91\x62\xa5\xca\xb5\xa2\xee\x09\xb0\
\x73\x52\x10\x7b\x14\x30\xe7\x08\xde\x50\xc0\x44\x61\x01\xea\x6d\
\x02\x0c\xe0\xea\xd5\x10\x5b\x2b\x01\x0a\x98\xa3\xeb\x00\x51\xe7\
\x75\xb9\x42\x44\xdc\x5e\x57\xcc\x90\xf0\x86\x02\xe5\x6e\x5f\x77\
\x04\x60\x42\xf3\x60\xdc\x1f\xf2\x1d\x0f\x14\xa9\x82\x00\x1b\xcf\
\xb7\xda\x9f\x9d\xaa\xba\xd5\x87\x70\x11\x19\x07\x2c\xb6\x3f\x77\
\xab\xea\x8a\x88\x6a\x99\xce\x51\x05\xcc\x8d\x4d\x80\xd6\x98\x7a\
\x6d\xc0\x7c\xfb\x5c\xe1\x51\x7e\x93\xd3\xee\xec\x98\x3a\xae\x4e\
\x7b\x62\xea\x24\x46\x01\x73\x5d\x15\x60\xa6\x88\x84\xcf\xfd\xf3\
\xc6\xed\x4e\x7a\x63\x6c\xad\x84\x28\x00\x5b\x30\xd7\x55\x60\xdc\
\x6d\x92\x6f\x21\x49\x21\x22\xa3\x80\x29\xf6\xa7\x62\x2e\x60\xbc\
\xa2\xa0\xe6\xa2\xb2\xdb\xc9\x6b\xf7\x2d\x24\x05\x66\x53\x9a\x00\
\xb7\xab\xaa\xcf\x6d\x38\x50\x0a\x87\x37\x38\x79\x0f\x89\x88\xd7\
\xcd\x46\x12\x88\xc8\x10\xe0\x71\x27\x6b\x43\x5c\xdd\x34\x08\xd8\
\xed\xc2\x1c\x3e\x5e\x0d\x0c\x03\x96\x00\x0f\x3b\xf5\x86\x3b\xe9\
\x16\x11\x99\x1c\xd1\xd6\x61\x55\x8d\x0c\x68\xec\x6c\xdf\x14\x51\
\x74\x95\x93\x1e\x1a\x2a\x9b\x0f\x8c\xb3\xe9\x43\xc0\xcb\x51\x6d\
\xa7\x86\x13\x74\x4c\xa3\xfc\xee\x6f\x82\x53\x76\xd6\x4e\x85\x6d\
\xfd\xd1\xc0\x6f\x4e\xd9\xa2\xac\x82\xad\x33\xa7\xc2\xaa\xba\x89\
\x52\xe8\xd9\x08\xac\x17\x91\xf3\xfd\x53\x5e\x19\x22\xd2\x00\xbc\
\x05\x5c\x60\xb3\xf6\x92\x55\xef\x53\x7e\x2a\x0c\xb0\x10\xd8\x0a\
\x9c\x8b\x59\xef\xd7\x88\xc8\x6d\x56\x89\xc0\x85\xfb\x30\x57\xe2\
\x61\xc4\xc5\xf3\x00\xbb\x81\xcf\x23\xf2\x87\x02\x97\xd9\x74\xb0\
\x25\x7f\x06\xb8\xd1\xa6\x15\x58\xa0\xaa\xc7\x2b\xb4\x9d\x0e\x11\
\xee\xda\x4e\xb9\x6b\x3e\x8f\x59\x2d\xce\x46\xec\xff\x48\x48\xf6\
\x92\xcc\x65\xc6\x28\xb2\x2c\xa4\x48\x17\x30\x3c\x43\xc3\x8b\xc0\
\x8b\x21\x99\xef\x13\x71\x43\x8c\x99\xab\x9e\x04\x16\x45\x95\xfb\
\x22\x40\x30\x57\xd4\xae\x42\xdf\x03\x2d\x19\x18\x3f\x1a\xf8\x28\
\x24\xab\x17\x73\x2f\xd8\xe1\x7a\x1f\x70\x07\xe6\xde\x22\xa8\xb7\
\x3a\x2d\x09\x95\x14\x6b\x00\x9e\x0d\x29\x76\x14\x78\xca\x87\x37\
\x00\x43\x80\x05\x94\xcf\xf6\x0a\x7c\x68\x8d\x0f\x7e\x77\x60\xf6\
\x2b\x61\xe3\xbd\x90\x50\x8d\xa2\xf7\x51\x7e\x5d\xae\x56\xe9\x47\
\xb1\x97\xa7\x35\x1a\x3e\x0a\xf3\xfd\xc1\xee\x08\x63\x96\x5a\xe2\
\x3b\x42\xf9\x9b\x63\x8c\x4f\x4d\x42\xb5\x4a\xb7\x02\x5f\xc5\x08\
\xff\x12\x78\xcc\xd6\x69\x06\x8a\xce\x7b\x05\xe0\x42\x4c\x7c\xb1\
\xc0\xba\x7a\x94\x21\x3f\x03\xb3\x42\xef\x85\x49\x18\xe8\x49\x44\
\x42\x2d\x3d\x27\x98\xaf\xc4\x76\x0d\xa0\xc8\x29\xcc\xa9\xcd\xaf\
\x03\xf4\x9a\x62\xee\xfe\x16\x01\xe7\x44\xc8\x2b\x50\x7e\x62\x9d\
\x09\x09\x49\xc6\x6e\x23\xf0\x20\x66\xac\x86\x3f\x70\xaa\xe6\x39\
\x8d\xb9\x29\x5e\x0c\x8c\xa8\x20\x27\x6e\xcc\x7b\x25\x21\xd1\xc4\
\xe1\x28\x39\x12\xb8\x0b\x78\x13\x73\x85\xb5\xdf\x7a\x80\x6b\xec\
\x41\xcc\x97\x26\xeb\x81\x07\x80\x31\x55\xb4\x9b\xd4\xf8\x9a\x49\
\x48\x45\x40\x8c\xf2\x45\x60\x2c\x70\x09\x30\x24\xc1\xfb\xd3\x52\
\x1a\x5f\x13\x09\x5e\x2f\x19\x00\xd4\x9c\xe3\xef\x4b\xd1\xc4\x64\
\xfe\xbb\x45\x4f\x82\xb9\x60\xce\x33\xb5\xc2\xc7\xd9\x85\xb8\x82\
\x1c\x11\x15\x67\x24\xc5\x5c\xa0\xd3\x06\x58\xd1\xf0\x3d\x04\x3c\
\x0c\xa1\x06\x8c\xfb\xa6\x1d\x02\x55\x0d\x87\xdc\x0d\xce\x9b\x84\
\xdc\x8d\xcd\x9b\x84\xdc\x0d\xcd\x9b\x84\xdc\x8d\xcc\x9b\x84\xdc\
\x0d\xcc\x9b\x84\x44\xff\x33\x94\x07\xec\x52\xd6\x89\x5d\xdf\x3d\
\xa1\x63\xd0\x10\x00\x99\x90\xb0\xb7\x1e\x37\x42\xb1\x50\xb3\xa3\
\x9b\x87\x89\x3d\x7c\xe0\xc8\xa0\xf2\x80\x00\x9e\x3c\xa1\x1f\x68\
\xcb\x7d\x82\xcb\x69\x62\x3c\x00\x5c\x39\x68\x56\x01\xcf\x24\x9c\
\x31\x7e\xd0\x13\x90\x80\x84\x32\xe3\x55\xb5\x2e\xa3\xc1\x9a\xa0\
\xd5\x4f\x8c\xfd\x40\x9b\xaa\xee\x74\x33\x07\x3d\x01\x50\x15\x09\
\x91\xc6\xc3\xff\x84\x00\xa8\x48\x42\xac\xf1\x90\xf0\xbf\xc7\xeb\
\x19\x76\x89\x7c\x05\x73\xc1\x7a\x04\x98\x13\x67\x3c\xc0\xbf\x17\
\xc5\x47\x80\xad\xb5\xf2\xa6\x00\x00\x00\x00\x49\x45\x4e\x44\xae\
\x42\x60\x82\
"

resource_name = b"\
\x00\x05\
\x00\x6f\xa6\x53\
\x00\x69\
\x00\x63\x00\x6f\x00\x6e\x00\x73\
\x00\x0f\
\x01\x68\x38\x67\
\x00\x7a\
\x00\x6f\x00\x6f\x00\x6d\x00\x5f\x00\x74\x00\x6f\x00\x5f\x00\x66\x00\x69\x00\x74\x00\x2e\x00\x70\x00\x6e\x00\x67\
"

resource_struct = b"\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x01\
\x00\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x02\
\x00\x00\x00\x10\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\
"

qRegisterResourceData(0x01, resource_struct, resource_name, resource_data)

LEVELS = range(-95, -20, 5)

_tmpdir = None

FREQS = [2412 + i * 5 for i in range(13)] + [2484] + [5180, 5200, 5220, 5240]
CHANS = [i for i in range(1, 15)] + [36, 40, 44, 48]

FREQ_TO_CHAN = dict(zip(FREQS, CHANS))

def save_heatmap(filepath, img_w, img_h, xs, ys, zs, scale_factor=0.2):
    ## Interpolate z-values throughout the 2D-space using linear radial
    ## basis function.
    rbf = scipy.interpolate.Rbf(xs, ys, zs, function='linear')

    spc_w = img_w * scale_factor
    spc_h = img_h * scale_factor

    spc_xs, spc_ys = [v.flatten() for v in numpy.meshgrid(
        numpy.linspace(0, img_w - 1, spc_w),
        numpy.linspace(0, img_h - 1, spc_h))]
    array2d = rbf(spc_xs, spc_ys).reshape((spc_h, spc_w))

    matplotlib.pyplot.imsave(filepath, array2d, format='png',
                             vmin=min(LEVELS), vmax=max(LEVELS),
                             cmap='RdYlBu_r')

class DrawHeatmapsThread(QThread):

    heatmapReady = pyqtSignal(int, str, QImage)

    def __init__(self):
        QThread.__init__(self)

        self.__doCancel    = False
        self.__heatmapData = []

    def drawHeatmaps(self, heatmapData):
        if not heatmapData:
            return

        self.__doCancel = True
        self.wait()

        self.__heatmapData = list(heatmapData)
        self.__doCancel    = False

        QThread.start(self)

    def run(self):
        while self.__heatmapData and not self.__doCancel:
            freq, bssid, *rest = self.__heatmapData.pop()

            filepath = os.path.join(_tmpdir, "%dHz_%s.png" % (freq, bssid))
            save_heatmap(filepath, *rest)

            img = QImage()
            img.load(filepath)

            self.heatmapReady.emit(freq, bssid, img)

class ZoomableGraphicsView(QGraphicsView):

    ZOOM_FACTOR = 1.1

    def __init__(self, *args):
        QGraphicsView.__init__(self, *args)

    def wheelEvent(self, event):
        if not event.modifiers() & Qt.ControlModifier:
            QGraphicsView.wheelEvent(self, event)
        else:
            self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

            if event.delta() > 0:
                self.scale(ZoomableGraphicsView.ZOOM_FACTOR,
                           ZoomableGraphicsView.ZOOM_FACTOR)
            else:
                self.scale(1 / ZoomableGraphicsView.ZOOM_FACTOR,
                           1 / ZoomableGraphicsView.ZOOM_FACTOR)

            event.accept()

    def fitAllInView(self):
        if self.scene() is not None:
            self.fitInView(self.scene().itemsBoundingRect(), Qt.KeepAspectRatio)

class HeatmapScene(QGraphicsScene):

    def __init__(self):
        QGraphicsScene.__init__(self)

        self.__heatmaps = {}
        self.__freqs    = []
        self.__bssids   = []

        self.__layoutPixmap = None

    def clear(self):
        self.__heatmaps = {}
        self.__freqs    = []
        self.__bssids   = []
        QGraphicsScene.clear(self)

    def setLayoutPixmap(self, pixmap):
        self.__layoutPixmap = pixmap

    def addHeatmap(self, freq, bssid, img):
        pixmap = QPixmap.fromImage(img)
        try:
            heatmap = self.__heatmaps[(freq, bssid)]
        except KeyError:
            heatmap = self.addPixmap(pixmap)
            layout = self.addPixmap(self.__layoutPixmap.scaled(pixmap.size()))
            try:
                x_offset = self.__freqs.index(freq)
            except ValueError:
                x_offset = len(self.__freqs)
                self.__freqs.append(freq)
            try:
                y_offset = self.__bssids.index(bssid)
            except ValueError:
                y_offset = len(self.__bssids)
                self.__bssids.append(bssid)
            margin = max(0.1 * pixmap.width(), 0.1 * pixmap.height())
            heatmap.moveBy(margin, margin)
            heatmap.moveBy(x_offset * (margin + pixmap.width()),
                           y_offset * (margin + pixmap.height()))
            layout.moveBy(margin, margin)
            layout.moveBy(x_offset * (margin + pixmap.width()),
                          y_offset * (margin + pixmap.height()))
            self.__heatmaps[(freq, bssid)] = heatmap
        else:
            heatmap.setPixmap(pixmap)

class MonitorScene(QGraphicsScene):

    measurementsChanged = pyqtSignal()

    def __init__(self, monitor):
        QGraphicsScene.__init__(self)

        self.__monitor = monitor

        self.__spots            = []
        self.__layoutPixmapItem = None

    def clear(self):
        self.__spots            = []
        self.__layoutPixmapItem = None
        QGraphicsScene.clear(self)

    def setLayoutPixmap(self, pixmap):
        if self.__layoutPixmapItem is None:
            self.__layoutPixmapItem = self.addPixmap(pixmap)
            self.__layoutPixmapItem.setZValue(-1)
            return
        self.__layoutPixmapItem.setPixmap(pixmap)

    def layoutPixmap(self):
        if self.__layoutPixmapItem is None:
            return None
        return self.__layoutPixmapItem.pixmap()

    def customEvent(self, event):
        if event.type() == SpotModifiedEvent.TYPE:
            self.measurementsChanged.emit()

    def measurements(self):
        result = {}

        xs = result['x'] = []
        ys = result['y'] = []

        bssidsets = {}

        for spot in self.__spots:

            measurement = spot.measurement()
            if measurement is None:
                continue

            xs.append(int(spot.pos().x()))
            ys.append(int(spot.pos().y()))

            for freq, bssids in measurement.items():
                bssidset = bssidsets.setdefault(freq, set())
                for bssid in bssids:
                    bssidset.add(bssid)

        for spot in self.__spots:

            measurement = spot.measurement()
            if measurement is None:
                continue

            for freq, bssidset in bssidsets.items():
                bssidmap = result.setdefault(freq, {})
                for bssid in bssidset:
                    values = bssidmap.setdefault(bssid, [])
                    value = measurement.get(freq, {}).get(bssid, min(LEVELS))
                    values.append(int(round(value)))

        return result

    def setSpotData(self, spotData):
        for spot in self.__spots:
            self.removeSpot(spot)

        for spotDatum in spotData:
            spot = self.addSpot(QPointF(spotDatum['x'], spotDatum['y']))
            spot.setMeasurement(spotDatum['measurement'])

    def spotData(self):
        data = []
        for spot in self.__spots:
            data.append({
                'x': spot.x(),
                'y': spot.y(),
                'measurement': spot.measurement(),
            })
        return data

    def addSpot(self, pos):
        spot = MonitorSpot(self.__monitor)
        spot.setPos(pos)
        self.addItem(spot)
        self.__spots.append(spot)
        return spot

    def mousePressEvent(self, event):
        QGraphicsScene.mousePressEvent(self, event)
        if event.isAccepted():
            return

        if self.__layoutPixmapItem is None:
            return

        if not self.__layoutPixmapItem.boundingRect().contains(event.scenePos()):
            return

        if (event.button() == Qt.LeftButton and not event.modifiers()):
            self.addSpot(event.scenePos())
            event.accept()
            return

    def removeSpot(self, spot):
        self.__spots.remove(spot)
        spot.stopMonitor()
        self.removeItem(spot)
        self.measurementsChanged.emit()

    def contextMenuEvent(self, event):
        spot = self.itemAt(event.scenePos())
        if spot is None:
            return

        menu = QMenu()
        removeAction = menu.addAction("&Remove")
        toggleAction = menu.addAction("&Toggle monitoring")

        action = menu.exec_(event.screenPos())
        if action is None:
            return

        if action is removeAction:
            self.removeSpot(spot)
        elif action is toggleAction:
            spot.toggleMonitor()

        event.accept()

class MonitorSpot(QGraphicsPolygonItem):

    SIZE = 20

    def __init__(self, monitor):
        QGraphicsPolygonItem.__init__(self)

        self.__monitor = monitor

        polygon       = QPolygonF()
        corners       = 5
        corner_angle  = math.pi / corners
        spoke_ratio   = 1 / 3
        for i in range(corners * 2):
            a     = corner_angle * i - 0.5 * corner_angle * (corners % 2)
            x     = math.cos(a)
            y     = math.sin(a)
            point = QPointF(x, y)

            if i % 2:
                point *= spoke_ratio

            polygon << point * MonitorSpot.SIZE;

        self.setPolygon(polygon)
        self.setBrush(QBrush(QColor("beige")))

        dropShadowEffect = QGraphicsDropShadowEffect()
        dropShadowEffect.setOffset(4)
        dropShadowEffect.setBlurRadius(5)
        self.setGraphicsEffect(dropShadowEffect)
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges)

        self.setAcceptHoverEvents(True)

        self.__measurement = None

        self.__animation = QGraphicsItemAnimation()
        self.__animation.setTimeLine(QTimeLine())
        self.__animation.setScaleAt(0.0, 1, 1)
        self.__animation.setScaleAt(0.5, 2, 2)
        self.__animation.setScaleAt(1.0, 1, 1)
        self.__animation.setRotationAt(0.0, 0)
        self.__animation.setRotationAt(0.5, 180)
        self.__animation.setRotationAt(1.0, 360)
        self.__animation.setItem(self)

        self.__hasMonitor = False

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemPositionHasChanged:
            if self.scene() is not None and self.__measurement is not None:
                QCoreApplication.postEvent(self.scene(), SpotModifiedEvent())
            return
        return QGraphicsPolygonItem.itemChange(self, change, value)

    def mouseDoubleClickEvent(self, event):
        self.toggleMonitor()

    def __monitorStarted(self):
        self.__animation.timeLine().setDuration(self.__monitor.channelDwellTime() * len(CHANS))
        self.__animation.timeLine().start()

    def __monitorStopped(self, isSuccess):
        self.__animation.timeLine().stop()
        self.__animation.setStep(0)

        if isSuccess:
            self.setMeasurement(self.__monitor.measurement)

        self.__monitor.started.disconnect(self.__monitorStarted)
        self.__monitor.stopped.disconnect(self.__monitorStopped)

        self.__hasMonitor = False

    def startMonitor(self):
        self.__monitor.terminate()
        self.__hasMonitor = True

        self.__monitor.started.connect(self.__monitorStarted)
        self.__monitor.stopped.connect(self.__monitorStopped)

        self.__monitor.start()

    def stopMonitor(self):
        if self.__hasMonitor:
            self.__monitor.terminate()

    def toggleMonitor(self):
        if self.__hasMonitor:
            self.stopMonitor()
        else:
            self.startMonitor()

    def hoverEnterEvent(self, event):
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def setMeasurement(self, measurement):
        self.__measurement = measurement
        self.setBrush(QBrush(QColor("lightgreen")))
        if self.scene() is not None:
            QCoreApplication.postEvent(self.scene(), SpotModifiedEvent())

    def measurement(self):
        return self.__measurement

class SpotModifiedEvent(QEvent):
    TYPE = QEvent.registerEventType()

    def __init__(self):
        QEvent.__init__(self, SpotModifiedEvent.TYPE)

def get_dot11_interfaces():
    result = []
    for iface in os.listdir('/sys/class/net'):
        if os.path.exists(os.path.join('/sys/class/net/', iface, 'phy80211')):
            result.append(iface)
    return result

class Monitor(QObject):

    MIN_CHANNEL_DWELL_TIME = 100
    MAX_CHANNEL_DWELL_TIME = 5000

    started = pyqtSignal()
    stopped = pyqtSignal(bool)

    def __init__(self, interface, *args):
        QObject.__init__(self, *args)

        self.__iface = interface

        self.__process = None
        self.__horst_errfile_path = os.path.join(_tmpdir, 'horst.err')
        self.__horst_configfile_path = os.path.join(_tmpdir, 'horst.conf')

        self.isTerminated = False
        self.setChannelDwellTime(500)

        self.__output = ''
        self.measurement = None

        self.essids = {}

    def channelDwellTime(self):
        return self.__dwell

    def setChannelDwellTime(self, millisecs):
        self.__dwell = max(Monitor.MIN_CHANNEL_DWELL_TIME,
                           min(millisecs, Monitor.MAX_CHANNEL_DWELL_TIME))

    def interface(self):
        return self.__iface

    def setInterface(self, interface):
        self.__iface = interface

    def start(self):
        if self.__process is not None:
            return False

        self.__process = QProcess(self)
        self.__process.setStandardErrorFile(self.__horst_errfile_path)

        self.__process.started.connect(self.started)
        self.__process.finished.connect(self.__emitStopped)
        self.__process.readyReadStandardOutput.connect(self.__outputReady)

        with open(self.__horst_configfile_path, 'w') as f:
            f.write('quiet\n')
            f.write('interface = {}\n'.format(self.__iface))
            f.write('filter_packet = BEACON\n')
            f.write('channel_upper = 48\n')
            f.write('channel_dwell = {}\n'.format(self.__dwell))
            f.write('channel = 1\n')
            f.write('channel_scan\n')
            f.write('channel_scan_rounds = 1\n')
            f.write('outfile = /dev/stdout\n')

        args = ['-c', self.__horst_configfile_path]

        self.measurement = None
        self.isTerminated = False
        self.__process.start("%s-horst" % os.path.abspath(__file__), args,
                             QIODevice.ReadOnly)

        return True

    def __outputReady(self):
        self.__output += bytes(self.__process.readAllStandardOutput()).decode()
        while self.__output:
            line, sep, self.__output = self.__output.partition('\n')
            if not sep:
                self.__output = line
                break

            if self.measurement is None:
                self.measurement = {}
                continue

            fields = [s.strip() for s in line.strip().split(',')]
            bssid = fields[4]
            rssi = int(fields[6])
            freq = int(fields[9])
            ssid = fields[11]
            self.essids[bssid] = ssid

            bssidmap = self.measurement.setdefault(freq, {})
            bssidmap[bssid] = (rssi + bssidmap.get(bssid, rssi)) / 2

    def errorText(self):
        with open(self.__horst_errfile_path) as errfile:
            return errfile.read()

    def __emitStopped(self, exitCode, exitStatus):
        isSuccess = exitStatus == QProcess.NormalExit and exitCode == 0
        self.stopped.emit(isSuccess)

    def terminate(self):
        if self.__process:
            self.isTerminated = True
            self.__process.close()
            self.__process = None

class MonitorWidget(QWidget):

    def __init__(self, monitor, *args):
        QWidget.__init__(self, *args)

        self.__monitor = monitor
        self.__monitor.started.connect(self.__disable)
        self.__monitor.stopped.connect(self.__enable)

        layout = QVBoxLayout()
        formLayout = QFormLayout()

        self.__errorMessageBox = QMessageBox(
            QMessageBox.Critical,
            "Monitor process terminated with error status",
            "",
            QMessageBox.Ok,
            self)
        self.__errorMessageBox.setModal(False)

        self.__ifaceComboBox = QComboBox()
        self.__ifaceComboBox.addItems(sorted(INTERFACES))
        self.__ifaceComboBox.setCurrentIndex(len(INTERFACES) - 1)
        self.__ifaceComboBox.activated.connect(self.__saveInterface)
        formLayout.addRow("Interface:", self.__ifaceComboBox)
        self.__monitor.setInterface(self.__ifaceComboBox.currentText())

        self.__dwellSpinBox = QSpinBox()
        self.__dwellSpinBox.setSuffix("ms")
        self.__dwellSpinBox.setMinimum(Monitor.MIN_CHANNEL_DWELL_TIME)
        self.__dwellSpinBox.setMaximum(Monitor.MAX_CHANNEL_DWELL_TIME)
        self.__dwellSpinBox.setSingleStep(50)
        self.__dwellSpinBox.setValue(monitor.channelDwellTime())
        self.__dwellSpinBox.valueChanged.connect(self.__saveDwell)

        dwellWhatsThis = """
        <p>

        <i>Channel dwell time</i> defines the time (in milliseconds) the
        monitor stays on one channel while it is measuring and hopping channels.

        </p>

        <p>

        The longer the dwell time the more complete the set of found BSS IDs,
        because the monitor has more chances to hear beacons. To maximize the
        chances of hearing beacons from all surrounding APs, the channel dwell
        time should be set a bit higher than the shortest expected beacon
        interval.

        </p>"""

        self.__dwellSpinBox.setWhatsThis(dwellWhatsThis)
        dwellLabel = QLabel("Channel dwell time:")
        dwellLabel.setWhatsThis(dwellWhatsThis)
        formLayout.addRow(dwellLabel, self.__dwellSpinBox)

        self.__progressBar = QProgressBar()
        self.__progressBar.setAlignment(Qt.AlignCenter)
        formLayout.addRow("Status:", self.__progressBar)

        layout.addLayout(formLayout)
        self.__view = ZoomableGraphicsView(self)
        self.__view.setRenderHints(QPainter.Antialiasing)
        layout.addWidget(self.__view)

        self.__toolBar = QToolBar()
        self.__toolBar.addAction(
            QIcon(":icons/zoom_to_fit"),
            "Zoom to fit").triggered.connect(self.__view.fitAllInView)

        layout.addWidget(self.__toolBar)

        self.setLayout(layout)

        self.__progressTimer = QTimer()
        self.__progressTimer.timeout.connect(self.__updateProgressBar)
        self.__progressBar.setFormat("Ready")
        self.__progressBar.setValue(0)

    def __updateProgressBar(self):
        self.__progressBar.setValue(self.__progressBar.value() +
                                    self.__monitor.channelDwellTime())

    def setScene(self, scene):
        self.__view.setScene(scene)

    def __disable(self):
        self.__ifaceComboBox.setEnabled(False)
        self.__dwellSpinBox.setEnabled(False)
        self.__progressTimer.start(self.__monitor.channelDwellTime())
        self.__progressBar.setMaximum(self.__monitor.channelDwellTime() * len(CHANS))
        self.__progressBar.setFormat("Scanning...")
        self.__progressBar.setValue(0)

    def __enable(self, isSuccess):
        self.__progressTimer.stop()
        self.__progressBar.setFormat("Ready")
        self.__progressBar.setValue(0)
        if not isSuccess and not self.__monitor.isTerminated:
            self.__errorMessageBox.setText(self.__monitor.errorText())
            self.__errorMessageBox.show()
            self.__errorMessageBox.raise_()
            self.__errorMessageBox.activateWindow()

        self.__progressBar.setFormat("Ready")
        self.__ifaceComboBox.setEnabled(True)
        self.__dwellSpinBox.setEnabled(True)

    def __saveInterface(self):
        self.__monitor.setInterface(self.__ifaceComboBox.currentText())

    def __saveDwell(self, value):
        self.__monitor.setChannelDwellTime(value)

class MainWindow(QMainWindow):

    def __init__(self, monitor, *args):
        QMainWindow.__init__(self, *args)

        self.__monitor = monitor

        self.__heatmapScene = HeatmapScene()
        self.__monitorScene = MonitorScene(monitor)
        self.__monitorScene.measurementsChanged.connect(self.updateHeatmaps)

        self.setWindowTitle("Puavo WLAN Mapper")

        view = ZoomableGraphicsView(self)
        view.setRenderHints(QPainter.Antialiasing)
        view.setScene(self.__heatmapScene)
        self.setCentralWidget(view)

        self.__setupDockWidgets()
        self.__setupActions()
        self.__setupMenus()

        self.__drawHeatmapsThread = DrawHeatmapsThread()
        self.__drawHeatmapsThread.heatmapReady.connect(self.__heatmapScene.addHeatmap)

    def updateHeatmaps(self):
        measurements = self.__monitorScene.measurements()

        xs = measurements.pop('x')
        ys = measurements.pop('y')

        width = self.__monitorScene.layoutPixmap().width()
        height = self.__monitorScene.layoutPixmap().height()

        heatmapData = []

        for freq, bssidmap in measurements.items():

            ## To RBF-interpolate, we need more than 1 measurement point.
            if len(xs) > 1:

                for bssid, zs in bssidmap.items():
                    heatmapData.append((freq, bssid, width, height, xs, ys, zs))

        self.__drawHeatmapsThread.drawHeatmaps(heatmapData)

    def closeEvent(self, event):
        self.__monitor.terminate()

    def sizeHint(self):
        return QSize(800, 600)

    def __setupActions(self):
        self.__aboutAction = QAction(self)
        self.__aboutAction.setText("&About...")
        self.__aboutAction.triggered.connect(self.__showAboutDialog)

        self.__newProjectAction = QAction(self)
        self.__newProjectAction.setText("&New project...")
        self.__newProjectAction.setShortcut(QKeySequence("Ctrl+N"))
        self.__newProjectAction.triggered.connect(self.__newProjectDialog)

        self.__saveProjectAsAction = QAction(self)
        self.__saveProjectAsAction.setText("&Save project as...")
        self.__saveProjectAsAction.setShortcut(QKeySequence("Ctrl+S"))
        self.__saveProjectAsAction.triggered.connect(self.__saveProjectAsDialog)
        self.__saveProjectAsAction.setEnabled(False)

        self.__openProjectAction = QAction(self)
        self.__openProjectAction.setText("&Open project...")
        self.__openProjectAction.setShortcut(QKeySequence("Ctrl+O"))
        self.__openProjectAction.triggered.connect(self.__openProjectDialog)

        self.__quitAction = QAction(self)
        self.__quitAction.setText("&Quit")
        self.__quitAction.setShortcut(QKeySequence("Ctrl+Q"))
        self.__quitAction.triggered.connect(self.close)

        self.__whatsThisAction = QWhatsThis.createAction()

    def __setupMenus(self):
        menuBar = QMenuBar()

        fileMenu = menuBar.addMenu("&File")
        fileMenu.addAction(self.__newProjectAction)
        fileMenu.addAction(self.__openProjectAction)
        fileMenu.addAction(self.__saveProjectAsAction)
        fileMenu.addSeparator()
        fileMenu.addAction(self.__quitAction)

        viewMenu = menuBar.addMenu("&View")
        viewMenu.addAction(self.__monitorDockWidget.toggleViewAction())

        helpMenu = menuBar.addMenu("&Help")
        helpMenu.addAction(self.__whatsThisAction)
        helpMenu.addAction(self.__aboutAction)

        self.setMenuBar(menuBar)

    def __setupDockWidgets(self):
        self.__monitorDockWidget = QDockWidget(self)
        self.__monitorWidget = MonitorWidget(self.__monitor, self)
        self.__monitorWidget.setScene(self.__monitorScene)
        self.__monitorDockWidget.setWidget(self.__monitorWidget)
        self.__monitorDockWidget.setWindowTitle("Monitor")
        self.addDockWidget(Qt.LeftDockWidgetArea, self.__monitorDockWidget)

    def __openProjectDialog(self):
        filepath = QFileDialog.getOpenFileName(None,
                                               "Open a project",
                                               QDir.currentPath(),
                                               "Compressed Tar archives (*.tar.gz)")
        if not filepath:
            return

        self.__saveProjectAsAction.setEnabled(True)
        self.__monitor.terminate()

        with tarfile.open(str(filepath), "r:gz") as archive_file:

            src_image = archive_file.extractfile("scene/layout.png")
            with open(os.path.join(_tmpdir, "layout.png"), "wb") as dst_image:
                shutil.copyfileobj(src_image, dst_image)
            pixmap = QPixmap(os.path.join(_tmpdir, "layout.png"))
            self.__heatmapScene.clear()
            self.__heatmapScene.setLayoutPixmap(pixmap)

            self.__monitorScene.clear()
            self.__monitorScene.setLayoutPixmap(pixmap)

            essids_picklefile = archive_file.extractfile("scene/essids.pickle")
            self.__monitor.essids = pickle.load(essids_picklefile)

            spots_picklefile = archive_file.extractfile("scene/spots.pickle")
            self.__monitorScene.setSpotData(pickle.load(spots_picklefile))

    def __saveProjectAsDialog(self):
        filepath = QFileDialog.getSaveFileName(None,
                                               "Save the project as",
                                               QDir.currentPath(),
                                               "GZipped Tar archives (*.tar.gz)")
        filepath = str(filepath)
        if not filepath:
            return

        if not str(filepath).endswith('.tar.gz'):
            filepath = '%s.tar.gz' % filepath

        scenedir = os.path.join(_tmpdir, "scene")
        try:
            shutil.rmtree(scenedir)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise e
        os.mkdir(scenedir)

        with open(os.path.join(scenedir, "spots.pickle"), "wb") as f:
            pickle.dump(self.__monitorScene.spotData(), f)

        with open(os.path.join(scenedir, "essids.pickle"), "wb") as f:
            pickle.dump(self.__monitor.essids, f)

        shutil.copy(os.path.join(_tmpdir, "layout.png"), scenedir)

        with tarfile.open(str(filepath), "w:gz") as f:
            f.add(scenedir, "scene")

    def __newProjectDialog(self):
        dialog = NewProjectDialog()
        if not dialog.exec_():
            return

        filepath = dialog.layoutImageFilePath()

        layoutPixmap = QPixmap(filepath, "png")
        if layoutPixmap.isNull():
            msg = "File {} could not be loaded as a layout image.\n\n" \
                  "Please ensure the layout image is a valid PNG file."
            QMessageBox.critical(self, "Failed to load a layout image",
                                 msg.format(filepath))
        else:
            shutil.copy(filepath, os.path.join(_tmpdir, "layout.png"))
            self.__heatmapScene.clear()
            self.__heatmapScene.setLayoutPixmap(layoutPixmap)

            self.__monitorScene.clear()
            self.__monitorScene.setLayoutPixmap(layoutPixmap)

            self.__saveProjectAsAction.setEnabled(True)
            self.__monitor.terminate()

    def __showAboutDialog(self):
        aboutText =  (
"<h1>Puavo WLAN Mapper</h1>"
"<p>Copyright © 2015 <a href=\"http://opinsys.fi\">Opinsys Oy</a></p>"
"<p>This program is free software: you can redistribute it and/or "
"modify it under the terms of the GNU General Public License as "
"published by the Free Software Foundation, either version 2 of the "
"License, or (at your option) any later version.</p>"
"<p>This program is distributed in the hope that it will be useful, but"
" WITHOUT ANY WARRANTY; without even the implied warranty of "
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>"
"<p>See the <a href=\"https://www.gnu.org/licenses/gpl-2.0.html\">GNU "
"General Public License</a> for more details.</p>"
        )

        QMessageBox.about(self, "About Puavo WLAN Mapper", aboutText)

class NewProjectDialog(QDialog):

    def __init__(self, *args):
        QDialog.__init__(self, *args)

        self.setModal(True)
        self.setWindowTitle("Create a new project")

        imageLineEdit = QLineEdit()
        imageLineEdit.textChanged.connect(self.__checkImageFilePath)
        browseButton = QPushButton("&Browse")
        browseButton.clicked.connect(self.__getLayoutImageFileName)

        cancelButton = QPushButton("&Cancel")
        cancelButton.clicked.connect(self.reject)
        createButton = QPushButton("Create")
        createButton.clicked.connect(self.accept)
        createButton.setEnabled(False)

        layout = QVBoxLayout(self)
        formLayout = QFormLayout()
        browseLayout = QHBoxLayout()
        buttonLayout = QHBoxLayout()

        browseLayout.addWidget(imageLineEdit)
        browseLayout.addWidget(browseButton)

        formLayout.addRow("Layout image:", browseLayout)

        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(createButton)

        layout.addLayout(formLayout)
        layout.addLayout(buttonLayout)

        self.__imageLineEdit = imageLineEdit
        self.__createButton = createButton

    def layoutImageFilePath(self):
        return self.__imageLineEdit.text()

    def __checkImageFilePath(self):
        self.__createButton.setEnabled(
            os.path.isfile(self.__imageLineEdit.text()))

    def __getLayoutImageFileName(self):
        filepath = QFileDialog.getOpenFileName(None,
                                               "Load layout image",
                                               QDir.currentPath(),
                                               "Images (*.png)")
        if filepath:
            self.__imageLineEdit.setText(filepath)

    def sizeHint(self):
        s = QDialog.sizeHint(self)
        return QSize(s.width() + self.__imageLineEdit.sizeHint().width() * 2,
                     s.height())

INTERFACES = get_dot11_interfaces()

def main():
    global _tmpdir
    try:
        _tmpdir = tempfile.mkdtemp(prefix='puavo-wlanmapper.')
        app = QApplication(sys.argv)

        if app.argc() > 1:
            error_message = "ERROR: invalid number of arguments ({})"
            print(error_message.format(app.argc() - 1), file=sys.stderr)
            print("Usage: {}".format(sys.argv[0]), file=sys.stderr)
            return 1

        if not INTERFACES:
            QMessageBox.critical(None, "Startup failure",
                                 "Failed to find any 802.11 devices.")
            sys.exit(1)

        monitor = Monitor(INTERFACES[0])

        win = MainWindow(monitor)
        win.show()

        sys.exit(app.exec_())
    finally:
        if _tmpdir:
            shutil.rmtree(_tmpdir)

if __name__ == "__main__":
    main()
