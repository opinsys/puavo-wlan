#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2015 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

from __future__ import division
from __future__ import print_function

import collections
import errno
import math
import os
import os.path
import pickle
import shutil
import sys
import tarfile
import tempfile

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import matplotlib.pyplot
import scipy.interpolate
import numpy

LEVELS = range(-95, -20, 5)

_tmpdir = None

FREQS = [2412 + i * 5 for i in range(13)] + [2484] + [5180, 5200, 5220, 5240]
CHANS = [i for i in range(1, 15)] + [36, 40, 44, 48]

FREQ_TO_CHAN = dict(zip(FREQS, CHANS))

def save_heatmap(filepath, img_w, img_h, xs, ys, zs, scale_factor=0.2):
    ## Interpolate z-values throughout the 2D-space using linear radial
    ## basis function.
    rbf = scipy.interpolate.Rbf(xs, ys, zs, function='linear')

    spc_w = img_w * scale_factor
    spc_h = img_h * scale_factor

    spc_xs, spc_ys = [v.flatten() for v in numpy.meshgrid(
        numpy.linspace(0, img_w - 1, spc_w),
        numpy.linspace(0, img_h - 1, spc_h))]
    array2d = rbf(spc_xs, spc_ys).reshape((spc_h, spc_w))

    matplotlib.pyplot.imsave(filepath, array2d, format='png',
                             vmin=min(LEVELS), vmax=max(LEVELS),
                             cmap='RdYlBu_r')

class ZoomableGraphicsView(QGraphicsView):

    ZOOM_FACTOR = 1.1

    def __init__(self, *args):
        QGraphicsView.__init__(self, *args)

    def wheelEvent(self, event):
        if not event.modifiers() & Qt.ControlModifier:
            QGraphicsView.wheelEvent(self, event)
        else:
            self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

            if event.delta() > 0:
                self.scale(ZoomableGraphicsView.ZOOM_FACTOR,
                           ZoomableGraphicsView.ZOOM_FACTOR)
            else:
                self.scale(1 / ZoomableGraphicsView.ZOOM_FACTOR,
                           1 / ZoomableGraphicsView.ZOOM_FACTOR)

            event.accept()

class MonitorScene(QGraphicsScene):

    heatmapsAdded = pyqtSignal(list)

    def __init__(self, monitor):
        QGraphicsScene.__init__(self)

        self.__monitor = monitor
        self.__monitor.started.connect(self.__monitorStarted)
        self.__monitor.stopped.connect(self.__monitorStopped)

        self.__spots = {}

        self.__layoutPixmapItem = self.addPixmap(QPixmap())
        self.__layoutPixmapItem.setZValue(-1)

        self.__heatmaps = {}
        self.__currentHeatmap = None

        timeLine = QTimeLine(2500)
        timeLine.setLoopCount(0)

        self.__animation = QGraphicsItemAnimation()
        self.__animation.setTimeLine(timeLine)
        self.__animation.setScaleAt(0.0, 1, 1)
        self.__animation.setScaleAt(0.5, 2, 2)
        self.__animation.setScaleAt(1.0, 1, 1)
        self.__animation.setRotationAt(0.0, 0)
        self.__animation.setRotationAt(0.5, 180)
        self.__animation.setRotationAt(1.0, 360)

    def setSpotData(self, spotData):
        for spotNumber in self.__spots.values():
            self.removeSpot(spot)

        for spotDatum in spotData:
            spot = self.addSpot(QPointF(spotDatum['x'], spotDatum['y']))
            self.__monitor.measurements[spot.number] = spotDatum['measurement']

    def spotData(self):
        data = []
        for spot in self.__spots.values():
            data.append({
                'x': spot.x(),
                'y': spot.y(),
                'measurement': self.__monitor.measurements[spot.number],
            })
        return data

    def addSpot(self, pos):
        spot = Spot()
        spot.setPos(pos)
        self.addItem(spot)
        self.__spots[spot.number] = spot
        return spot

    def setLayoutPixmap(self, pixmap):
        self.__layoutPixmapItem.setPixmap(pixmap)

    def setCurrentHeatmap(self, heatmapName):
        if self.__currentHeatmap is not None:
            self.__currentHeatmap.setVisible(False)
        self.__currentHeatmap = self.__heatmaps[str(heatmapName)]
        self.__currentHeatmap.setVisible(True)

    def heatmapNames(self):
        return self.__heatmaps.keys()

    def mousePressEvent(self, event):
        QGraphicsScene.mousePressEvent(self, event)
        if (not event.isAccepted()
            and event.button() == Qt.LeftButton
            and not event.modifiers()):
            self.addSpot(event.scenePos())
            event.accept()

    def removeSpot(self, spot):
        self.__spots.pop(spot.number)
        self.stopMonitoring(spot)
        self.removeItem(spot)

    def __monitorStarted(self):
        self.__animation.setItem(self.__currentSpot)
        self.__animation.timeLine().start()

    def __monitorStopped(self, isSuccess):
        self.__animation.timeLine().stop()
        self.__animation.setStep(0)

    def stopMonitoring(self, spot):
        if spot.number == self.__monitor.spotNumber:
            self.__monitor.terminate()
            return True
        return False

    def toggleMonitoring(self, spot):
        if not self.stopMonitoring(spot):
            self.__monitor.terminate()
            self.__monitor.start(spot.number)

    def mouseDoubleClickEvent(self, event):
        spot = self.itemAt(event.scenePos())
        if spot is None:
            return

        self.toggleMonitoring(spot)

        event.accept()

    def contextMenuEvent(self, event):
        spot = self.itemAt(event.scenePos())
        if spot is None:
            return


        menu = QMenu()
        removeAction = menu.addAction("&Remove")
        toggleAction = menu.addAction("&Toggle monitoring")

        action = menu.exec_(event.screenPos())
        if action is None:
            return

        if action is removeAction:
            self.removeSpot(spot)
        elif action is toggleAction:
            self.toggleMonitoring(spot)

        event.accept()

class Spot(QGraphicsPolygonItem):

    SIZE = 20

    __number = 1

    def __init__(self):
        QGraphicsPolygonItem.__init__(self)

        polygon       = QPolygonF()
        corners       = 5
        corner_angle  = math.pi / corners
        spoke_ratio   = 1 / 3
        for i in range(corners * 2):
            a     = corner_angle * i - 0.5 * corner_angle * (corners % 2)
            x     = math.cos(a)
            y     = math.sin(a)
            point = QPointF(x, y)

            if i % 2:
                point *= spoke_ratio

            polygon << point * Spot.SIZE;

        self.setPolygon(polygon)
        self.setBrush(QBrush(QColor("beige")))

        dropShadowEffect = QGraphicsDropShadowEffect()
        dropShadowEffect.setOffset(4)
        dropShadowEffect.setBlurRadius(5)
        self.setGraphicsEffect(dropShadowEffect)
        self.setFlag(QGraphicsItem.ItemIsMovable)

        self.setAcceptHoverEvents(True)

        Spot.__number += 1
        self.number = Spot.__number

    def hoverEnterEvent(self, event):
        self.setCursor(QCursor(Qt.PointingHandCursor))

def get_dot11_interfaces():
    result = []
    for iface in os.listdir('/sys/class/net'):
        if os.path.exists(os.path.join('/sys/class/net/', iface, 'phy80211')):
            result.append(iface)
    return result

class Monitor(QObject):

    MIN_CHANNEL_DWELL_TIME = 100
    MAX_CHANNEL_DWELL_TIME = 5000

    started = pyqtSignal(int)
    stopped = pyqtSignal(bool)

    def __init__(self, interface, *args):
        QObject.__init__(self, *args)

        self.__iface = interface

        self.__process = None
        self.__horst_errfile_path = os.path.join(_tmpdir, 'horst.err')
        self.__horst_configfile_path = os.path.join(_tmpdir, 'horst.conf')

        self.isTerminated = False
        self.setChannelDwellTime(500)

        self.spotNumber = None

        self.__output = ''
        self.__measurement = None

        self.essids = {}
        self.measurements = {}

    def channelDwellTime(self):
        return self.__dwell

    def setChannelDwellTime(self, millisecs):
        self.__dwell = max(Monitor.MIN_CHANNEL_DWELL_TIME,
                           min(millisecs, Monitor.MAX_CHANNEL_DWELL_TIME))

    def interface(self):
        return self.__iface

    def setInterface(self, interface):
        self.__iface = interface

    def start(self, spotNumber):
        if self.__process is not None:
            return False

        self.__process = QProcess(self)
        self.__process.setStandardErrorFile(self.__horst_errfile_path)

        self.__process.started.connect(self.__emitStarted)
        self.__process.finished.connect(self.__emitStopped)
        self.__process.readyReadStandardOutput.connect(self.__outputReady)

        with open(self.__horst_configfile_path, 'w') as f:
            f.write('quiet\n')
            f.write('interface = {}\n'.format(self.__iface))
            f.write('filter_packet = BEACON\n')
            f.write('channel_upper = 48\n')
            f.write('channel_dwell = {}\n'.format(self.__dwell))
            f.write('channel = 1\n')
            f.write('channel_scan\n')
            f.write('channel_scan_rounds = 1\n')
            f.write('outfile = /dev/stdout\n')

        args = ['-c', self.__horst_configfile_path]

        self.__measurement = None
        self.isTerminated = False
        self.spotNumber = spotNumber
        self.__process.start("%s-horst" % os.path.abspath(__file__), args,
                             QIODevice.ReadOnly)

        return True

    def __outputReady(self):
        self.__output += bytes(self.__process.readAllStandardOutput()).decode()
        while self.__output:
            line, sep, self.__output = self.__output.partition('\n')
            if not sep:
                self.__output = line
                break

            if self.__measurement is None:
                self.__measurement = {}
                continue

            fields = [s.strip() for s in line.strip().split(',')]
            bssid = fields[4]
            rssi = int(fields[6])
            freq = int(fields[9])
            ssid = fields[11]
            self.essids[bssid] = ssid

            bssidmap = self.__measurement.setdefault(freq, {})
            bssidmap[bssid] = (rssi + bssidmap.get(bssid, rssi)) / 2

    def errorText(self):
        with open(self.__horst_errfile_path) as errfile:
            return errfile.read()

    def __emitStarted(self):
        self.started.emit(self.spotNumber)

    def __emitStopped(self, exitCode, exitStatus):
        isSuccess = exitStatus == QProcess.NormalExit and exitCode == 0

        if isSuccess:
            self.measurements[self.spotNumber] = self.__measurement
            self.__measurement = None

        self.stopped.emit(isSuccess)

    def terminate(self):
        if self.__process:
            self.isTerminated = True
            self.spotNumber = None
            self.__process.close()
            self.__process = None

class MonitorWidget(QWidget):

    def __init__(self, monitor, *args):
        QWidget.__init__(self, *args)

        self.__monitor = monitor
        self.__monitor.started.connect(self.__disable)
        self.__monitor.stopped.connect(self.__enable)

        layout = QVBoxLayout()
        formLayout = QFormLayout()

        self.__errorMessageBox = QMessageBox(
            QMessageBox.Critical,
            "Monitor process terminated with error status",
            "",
            QMessageBox.Ok,
            self)
        self.__errorMessageBox.setModal(False)

        self.__ifaceComboBox = QComboBox()
        self.__ifaceComboBox.addItems(sorted(INTERFACES))
        self.__ifaceComboBox.setCurrentIndex(len(INTERFACES) - 1)
        self.__ifaceComboBox.activated.connect(self.__saveInterface)
        formLayout.addRow("Interface:", self.__ifaceComboBox)
        self.__monitor.setInterface(self.__ifaceComboBox.currentText())

        self.__dwellSpinBox = QSpinBox()
        self.__dwellSpinBox.setSuffix("ms")
        self.__dwellSpinBox.setMinimum(Monitor.MIN_CHANNEL_DWELL_TIME)
        self.__dwellSpinBox.setMaximum(Monitor.MAX_CHANNEL_DWELL_TIME)
        self.__dwellSpinBox.setSingleStep(50)
        self.__dwellSpinBox.setValue(monitor.channelDwellTime())
        self.__dwellSpinBox.valueChanged.connect(self.__saveDwell)

        dwellWhatsThis = """
        <p>

        <i>Channel dwell time</i> defines the time (in milliseconds) the
        monitor stays on one channel while it is measuring and hopping channels.

        </p>

        <p>

        The longer the dwell time the more complete the set of found BSS IDs,
        because the monitor has more chances to hear beacons. To maximize the
        chances of hearing beacons from all surrounding APs, the channel dwell
        time should be set a bit higher than the shortest expected beacon
        interval.

        </p>"""

        self.__dwellSpinBox.setWhatsThis(dwellWhatsThis)
        dwellLabel = QLabel("Channel dwell time:")
        dwellLabel.setWhatsThis(dwellWhatsThis)
        formLayout.addRow(dwellLabel, self.__dwellSpinBox)

        self.__progressBar = QProgressBar()
        self.__progressBar.setAlignment(Qt.AlignCenter)
        formLayout.addRow("Status:", self.__progressBar)

        layout.addLayout(formLayout)
        self.__view = ZoomableGraphicsView(self)
        self.__view.setRenderHints(QPainter.Antialiasing)
        layout.addWidget(self.__view)

        self.setLayout(layout)

        self.__progressTimer = QTimer()
        self.__progressTimer.timeout.connect(self.__updateProgressBar)
        self.__progressBar.setFormat("Ready")
        self.__progressBar.setValue(0)

    def __updateProgressBar(self):
        self.__progressBar.setValue(self.__progressBar.value() +
                                    self.__monitor.channelDwellTime())

    def setScene(self, scene):
        self.__view.setScene(scene)

    def __disable(self):
        self.__ifaceComboBox.setEnabled(False)
        self.__dwellSpinBox.setEnabled(False)
        self.__progressTimer.start(self.__monitor.channelDwellTime())
        self.__progressBar.setMaximum(self.__monitor.channelDwellTime() * len(CHANS))
        self.__progressBar.setFormat("Scanning...")
        self.__progressBar.setValue(0)

    def __enable(self, isSuccess):
        self.__progressTimer.stop()
        self.__progressBar.setFormat("Ready")
        self.__progressBar.setValue(0)
        if not isSuccess and not self.__monitor.isTerminated:
            self.__errorMessageBox.setText(self.__monitor.errorText())
            self.__errorMessageBox.show()
            self.__errorMessageBox.raise_()
            self.__errorMessageBox.activateWindow()

        self.__progressBar.setFormat("Ready")
        self.__ifaceComboBox.setEnabled(True)
        self.__dwellSpinBox.setEnabled(True)

    def __saveInterface(self):
        self.__monitor.setInterface(self.__ifaceComboBox.currentText())

    def __saveDwell(self, value):
        self.__monitor.setChannelDwellTime(value)

class MainWindow(QMainWindow):

    def __init__(self, monitor, *args):
        QMainWindow.__init__(self, *args)

        self.__monitor = monitor

        self.__monitorScene = None

        self.setWindowTitle("Puavo WLAN Mapper")

        view = ZoomableGraphicsView(self)
        view.setRenderHints(QPainter.Antialiasing)
        self.setCentralWidget(view)

        self.__setupDockWidgets()
        self.__setupActions()
        self.__setupMenus()

    def closeEvent(self, event):
        self.__monitor.terminate()

    def sizeHint(self):
        return QSize(800, 600)

    def __setupActions(self):
        self.__aboutAction = QAction(self)
        self.__aboutAction.setText("&About...")
        self.__aboutAction.triggered.connect(self.__showAboutDialog)

        self.__newProjectAction = QAction(self)
        self.__newProjectAction.setText("&New project...")
        self.__newProjectAction.setShortcut(QKeySequence("Ctrl+N"))
        self.__newProjectAction.triggered.connect(self.__newProjectDialog)

        self.__saveProjectAsAction = QAction(self)
        self.__saveProjectAsAction.setText("&Save project as...")
        self.__saveProjectAsAction.setShortcut(QKeySequence("Ctrl+S"))
        self.__saveProjectAsAction.triggered.connect(self.__saveProjectAsDialog)
        self.__saveProjectAsAction.setEnabled(False)

        self.__openProjectAction = QAction(self)
        self.__openProjectAction.setText("&Open project...")
        self.__openProjectAction.setShortcut(QKeySequence("Ctrl+O"))
        self.__openProjectAction.triggered.connect(self.__openProjectDialog)

        self.__quitAction = QAction(self)
        self.__quitAction.setText("&Quit")
        self.__quitAction.setShortcut(QKeySequence("Ctrl+Q"))
        self.__quitAction.triggered.connect(self.close)

        self.__whatsThisAction = QWhatsThis.createAction()

    def __setupMenus(self):
        menuBar = QMenuBar()

        fileMenu = menuBar.addMenu("&File")
        fileMenu.addAction(self.__newProjectAction)
        fileMenu.addAction(self.__openProjectAction)
        fileMenu.addAction(self.__saveProjectAsAction)
        fileMenu.addSeparator()
        fileMenu.addAction(self.__quitAction)

        viewMenu = menuBar.addMenu("&View")
        viewMenu.addAction(self.__monitorDockWidget.toggleViewAction())

        helpMenu = menuBar.addMenu("&Help")
        helpMenu.addAction(self.__whatsThisAction)
        helpMenu.addAction(self.__aboutAction)

        self.setMenuBar(menuBar)

    def __setupDockWidgets(self):
        self.__monitorDockWidget = QDockWidget(self)
        self.__monitorWidget = MonitorWidget(self.__monitor, self)
        self.__monitorDockWidget.setWidget(self.__monitorWidget)
        self.__monitorDockWidget.setWindowTitle("Monitor")
        self.addDockWidget(Qt.LeftDockWidgetArea, self.__monitorDockWidget)

    def __openProjectDialog(self):
        filepath = QFileDialog.getOpenFileName(None,
                                               "Open a project",
                                               QDir.currentPath(),
                                               "Compressed Tar archives (*.tar.gz)")
        if not filepath:
            return

        self.__monitorScene = MonitorScene(self.__monitor)
        self.__saveProjectAsAction.setEnabled(True)
        self.__monitorWidget.setScene(self.__monitorScene)
        self.__monitor.terminate()

        with tarfile.open(str(filepath), "r:gz") as archive_file:

            src_image = archive_file.extractfile("scene/layout.png")
            with open(os.path.join(_tmpdir, "layout.png"), "wb") as dst_image:
                shutil.copyfileobj(src_image, dst_image)
            self.__monitorScene.setLayoutPixmap(
                QPixmap(os.path.join(_tmpdir, "layout.png")))

            essids_picklefile = archive_file.extractfile("scene/essids.pickle")
            self.__monitor.essids = pickle.load(essids_picklefile)

            spots_picklefile = archive_file.extractfile("scene/spots.pickle")
            self.__monitorScene.setSpotData(pickle.load(spots_picklefile))

    def __saveProjectAsDialog(self):
        filepath = QFileDialog.getSaveFileName(None,
                                               "Save the project as",
                                               QDir.currentPath(),
                                               "GZipped Tar archives (*.tar.gz)")
        filepath = str(filepath)
        if not filepath:
            return

        if not str(filepath).endswith('.tar.gz'):
            filepath = '%s.tar.gz' % filepath

        scenedir = os.path.join(_tmpdir, "scene")
        try:
            shutil.rmtree(scenedir)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise e
        os.mkdir(scenedir)

        with open(os.path.join(scenedir, "spots.pickle"), "wb") as f:
            pickle.dump(self.__monitorScene.spotData(), f)

        with open(os.path.join(scenedir, "essids.pickle"), "wb") as f:
            pickle.dump(self.__monitor.essids, f)

        shutil.copy(os.path.join(_tmpdir, "layout.png"), scenedir)

        with tarfile.open(str(filepath), "w:gz") as f:
            f.add(scenedir, "scene")

    def __newProjectDialog(self):
        dialog = NewProjectDialog()
        if not dialog.exec_():
            return

        filepath = dialog.layoutImageFilePath()

        layoutPixmap = QPixmap(filepath, "png")
        if layoutPixmap.isNull():
            msg = "File {} could not be loaded as a layout image.\n\n" \
                  "Please ensure the layout image is a valid PNG file."
            QMessageBox.critical(self, "Failed to load a layout image",
                                 msg.format(filepath))
        else:
            shutil.copy(filepath, os.path.join(_tmpdir, "layout.png"))
            self.__monitorScene = MonitorScene(self.__monitor)
            self.__monitorScene.setLayoutPixmap(layoutPixmap)
            self.__saveProjectAsAction.setEnabled(True)
            self.__monitorWidget.setScene(self.__monitorScene)
            self.__monitor.terminate()

    def __showAboutDialog(self):
        aboutText =  (
"<h1>Puavo WLAN Mapper</h1>"
"<p>Copyright © 2015 <a href=\"http://opinsys.fi\">Opinsys Oy</a></p>"
"<p>This program is free software: you can redistribute it and/or "
"modify it under the terms of the GNU General Public License as "
"published by the Free Software Foundation, either version 2 of the "
"License, or (at your option) any later version.</p>"
"<p>This program is distributed in the hope that it will be useful, but"
" WITHOUT ANY WARRANTY; without even the implied warranty of "
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>"
"<p>See the <a href=\"https://www.gnu.org/licenses/gpl-2.0.html\">GNU "
"General Public License</a> for more details.</p>"
        )

        QMessageBox.about(self, "About Puavo WLAN Mapper", aboutText)

class NewProjectDialog(QDialog):

    def __init__(self, *args):
        QDialog.__init__(self, *args)

        self.setModal(True)
        self.setWindowTitle("Create a new project")

        imageLineEdit = QLineEdit()
        imageLineEdit.textChanged.connect(self.__checkImageFilePath)
        browseButton = QPushButton("&Browse")
        browseButton.clicked.connect(self.__getLayoutImageFileName)

        cancelButton = QPushButton("&Cancel")
        cancelButton.clicked.connect(self.reject)
        createButton = QPushButton("Create")
        createButton.clicked.connect(self.accept)
        createButton.setEnabled(False)

        layout = QVBoxLayout(self)
        formLayout = QFormLayout()
        browseLayout = QHBoxLayout()
        buttonLayout = QHBoxLayout()

        browseLayout.addWidget(imageLineEdit)
        browseLayout.addWidget(browseButton)

        formLayout.addRow("Layout image:", browseLayout)

        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(createButton)

        layout.addLayout(formLayout)
        layout.addLayout(buttonLayout)

        self.__imageLineEdit = imageLineEdit
        self.__createButton = createButton

    def layoutImageFilePath(self):
        return self.__imageLineEdit.text()

    def __checkImageFilePath(self):
        self.__createButton.setEnabled(
            os.path.isfile(self.__imageLineEdit.text()))

    def __getLayoutImageFileName(self):
        filepath = QFileDialog.getOpenFileName(None,
                                               "Load layout image",
                                               QDir.currentPath(),
                                               "Images (*.png)")
        if filepath:
            self.__imageLineEdit.setText(filepath)

    def sizeHint(self):
        s = QDialog.sizeHint(self)
        return QSize(s.width() + self.__imageLineEdit.sizeHint().width() * 2,
                     s.height())

INTERFACES = get_dot11_interfaces()

def main():
    global _tmpdir
    try:
        _tmpdir = tempfile.mkdtemp(prefix='puavo-wlanmapper.')
        app = QApplication(sys.argv)

        if app.argc() > 1:
            error_message = "ERROR: invalid number of arguments ({})"
            print(error_message.format(app.argc() - 1), file=sys.stderr)
            print("Usage: {}".format(sys.argv[0]), file=sys.stderr)
            return 1

        if not INTERFACES:
            QMessageBox.critical(None, "Startup failure",
                                 "Failed to find any 802.11 devices.")
            sys.exit(1)

        monitor = Monitor(INTERFACES[0])

        win = MainWindow(monitor)
        win.show()

        sys.exit(app.exec_())
    finally:
        if _tmpdir:
            shutil.rmtree(_tmpdir)

if __name__ == "__main__":
    main()
