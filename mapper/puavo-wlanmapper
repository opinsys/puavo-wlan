#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (C) 2015 Opinsys Oy
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

from __future__ import division
from __future__ import print_function

import collections
import errno
import math
import os
import os.path
import pickle
import shutil
import sys
import tarfile
import tempfile

from PyQt4.QtCore import *
from PyQt4.QtGui import *

import matplotlib.pyplot
import scipy.interpolate
import numpy

LEVELS = range(-95, -20, 5)

_tmpdir = None

FREQS = [2412 + i * 5 for i in range(13)] + [2484] + [5180, 5200, 5220, 5240]
CHANS = range(1, 15) + [36, 40, 44, 48]

FREQ_TO_CHAN = dict(zip(FREQS, CHANS))

def save_heatmap(filepath, img_w, img_h, xs, ys, zs, scale_factor=0.2):
    ## Interpolate z-values throughout the 2D-space using linear radial
    ## basis function.
    rbf = scipy.interpolate.Rbf(xs, ys, zs, function='linear')

    spc_w = img_w * scale_factor
    spc_h = img_h * scale_factor

    spc_xs, spc_ys = [v.flatten() for v in numpy.meshgrid(numpy.linspace(0, img_w - 1, spc_w),
                                                          numpy.linspace(0, img_h - 1, spc_h))]
    array2d = rbf(spc_xs, spc_ys).reshape((spc_h, spc_w))

    matplotlib.pyplot.imsave(filepath, array2d, format='png',
                             vmin=min(LEVELS), vmax=max(LEVELS), cmap='RdYlBu_r')

class ZoomableGraphicsView(QGraphicsView):

    ZOOM_FACTOR = 1.1

    def __init__(self, *args):
        QGraphicsView.__init__(self, *args)

    def wheelEvent(self, event):
        if not event.modifiers() & Qt.ControlModifier:
            QGraphicsView.wheelEvent(self, event)
        else:
            self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)

            if event.delta() > 0:
                self.scale(ZoomableGraphicsView.ZOOM_FACTOR,
                           ZoomableGraphicsView.ZOOM_FACTOR)
            else:
                self.scale(1 / ZoomableGraphicsView.ZOOM_FACTOR,
                           1 / ZoomableGraphicsView.ZOOM_FACTOR)

            event.accept()

class MonitorScene(QGraphicsScene):

    heatmapsAdded = pyqtSignal(QStringList)

    def __init__(self, monitor):
        QGraphicsScene.__init__(self)

        self.__monitor = monitor
        self.__monitor.started.connect(self.__monitorStarted)
        self.__monitor.stopped.connect(self.__monitorStopped)
        self.__monitoredSpot = None

        self.__spots = []
        self.essids = {}

        self.__layoutPixmapItem = self.addPixmap(QPixmap())
        self.__layoutPixmapItem.setZValue(-1)

        self.__heatmaps = {}
        self.__currentHeatmap = None

        timeLine = QTimeLine(2500)
        timeLine.setLoopCount(0)

        self.__animation = QGraphicsItemAnimation()
        self.__animation.setTimeLine(timeLine)
        self.__animation.setScaleAt(0.0, 1, 1)
        self.__animation.setScaleAt(0.5, 2, 2)
        self.__animation.setScaleAt(1.0, 1, 1)
        self.__animation.setRotationAt(0.0, 0)
        self.__animation.setRotationAt(0.5, 180)
        self.__animation.setRotationAt(1.0, 360)

    def setSpotData(self, spotData):
        for spot in self.__spots:
            self.removeSpot(spot)

        for spotDatum in spotData:
            item = self.addSpot(QPointF(spotDatum['x'], spotDatum['y']))
            item.measurement = spotDatum['measurement']

    def spotData(self):
        data = []
        for spot in self.__spots:
            data.append({
                'x': spot.x(),
                'y': spot.y(),
                'measurement': spot.measurement,
            })
        return data

    def addSpot(self, pos):
        item = Spot()
        item.setPos(pos)
        self.addItem(item)
        self.__spots.append(item)
        return item

    def setLayoutPixmap(self, pixmap):
        self.__layoutPixmapItem.setPixmap(pixmap)

    def setCurrentHeatmap(self, heatmapName):
        if self.__currentHeatmap is not None:
            self.__currentHeatmap.setVisible(False)
        self.__currentHeatmap = self.__heatmaps[str(heatmapName)]
        self.__currentHeatmap.setVisible(True)

    def heatmapNames(self):
        return self.__heatmaps.keys()

    def mousePressEvent(self, event):
        QGraphicsScene.mousePressEvent(self, event)
        if not event.isAccepted() and event.button() == Qt.LeftButton and not event.modifiers():
            self.addSpot(event.scenePos())
            event.accept()

    def removeSpot(self, spot):
        self.__spots.remove(spot)
        if spot == self.__monitoredSpot:
            self.toggleMonitoring(spot)
        self.removeItem(spot)
        self.updateHeatmaps()

    def __monitorStarted(self):
        self.__animation.setItem(self.__monitoredSpot)
        self.__animation.timeLine().start()

    def __monitorStopped(self, isSuccess):
        self.__animation.timeLine().stop()
        self.__animation.setStep(0)

        if isSuccess:

            measurement = {}
            for beacon in self.__monitor.readBeacons():
                bssidmap = measurement.setdefault(beacon.freq, {})
                rssi = bssidmap.get(beacon.bssid, beacon.rssi)
                bssidmap[beacon.bssid] = (beacon.rssi + rssi) / 2
                self.essids[beacon.bssid] = beacon.ssid
            self.__monitoredSpot.measurement = measurement

            self.toggleMonitoring(self.__monitoredSpot)

            self.updateHeatmaps()

    def toggleMonitoring(self, spot):
        self.__monitor.terminate()

        if self.__monitoredSpot == spot:
            self.__monitoredSpot = None
            return

        self.__monitoredSpot = spot

        self.__monitor.start()

    def updateHeatmaps(self):
        measurements = self.measurements()

        xs = measurements.pop('x')
        ys = measurements.pop('y')

        width = self.__layoutPixmapItem.pixmap().width()
        height = self.__layoutPixmapItem.pixmap().height()

        for freq, bssidmap in measurements.items():

            oldHeatmapNames = set(self.__heatmaps.keys())

            ## To RBF-interpolate, we need more than 1 measurement point.
            if len(xs) > 1:

                for bssid, zs in bssidmap.items():
                    heatmap_name = "%dHz_%s" % (freq, bssid)
                    heatmap_filepath = os.path.join(_tmpdir, "{}.png".format(heatmap_name))
                    save_heatmap(heatmap_filepath, width, height, xs, ys, zs)

                    pixmap = QPixmap(heatmap_filepath).scaled(width, height)
                    try:
                        self.__heatmaps[heatmap_name].setPixmap(pixmap)
                    except KeyError:
                        heatmap = self.addPixmap(pixmap)
                        heatmap.setVisible(False)
                        heatmap.setZValue(-2)
                        self.__heatmaps[heatmap_name] = heatmap

            newHeatmapNames = list(set(self.__heatmaps.keys()) - oldHeatmapNames)
            if newHeatmapNames:
                self.heatmapsAdded.emit(newHeatmapNames)

    def measurements(self):
        result = collections.OrderedDict()

        xs = result['x'] = []
        ys = result['y'] = []

        bssidsets = {}

        for spot in self.__spots:

            if spot.measurement is None:
                continue

            xs.append(int(spot.pos().x()))
            ys.append(int(spot.pos().y()))

            for freq, bssids in spot.measurement.items():
                bssidset = bssidsets.setdefault(freq, set())
                for bssid in bssids:
                    bssidset.add(bssid)

        for spot in self.__spots:

            if spot.measurement is None:
                continue

            for freq, bssidset in bssidsets.items():
                bssidmap = result.setdefault(freq, {})
                for bssid in bssidset:
                    values = bssidmap.setdefault(bssid, [])
                    value = spot.measurement.get(freq, {}).get(bssid, min(LEVELS))
                    values.append(int(round(value)))

        return result

class Spot(QGraphicsPolygonItem):

    SIZE = 30

    def __init__(self):
        QGraphicsPolygonItem.__init__(self)

        points = []
        for i in range(5):
            point = QPointF(0.5 + 0.5 * math.cos(4 / 5 * math.pi * i),
                            0.5 + 0.5 * math.sin(4 / 5 * math.pi * i))
            points.append(point * Spot.SIZE)

        self.setPolygon(QPolygonF(points).translated(-Spot.SIZE / 2,
                                                     -Spot.SIZE / 2))
        self.setFillRule(Qt.WindingFill)

        dropShadowEffect = QGraphicsDropShadowEffect()
        dropShadowEffect.setOffset(2)
        self.setGraphicsEffect(dropShadowEffect)
        self.setFlag(QGraphicsItem.ItemIsMovable)

        self.setAcceptHoverEvents(True)

        self.measurement = None

        self.__removeAction = QAction("&Remove", None)
        self.__removeAction.triggered.connect(self.__remove)

        self.__toggleMonitoringAction = QAction("&Toggle monitoring", None)
        self.__toggleMonitoringAction.triggered.connect(self.__toggleMonitoring)

        self.__contextMenu = QMenu()
        self.__contextMenu.addAction(self.__removeAction)
        self.__contextMenu.addAction(self.__toggleMonitoringAction)

    def __toggleMonitoring(self):
        self.scene().toggleMonitoring(self)

    def __remove(self):
        self.scene().removeSpot(self)

    def hoverEnterEvent(self, event):
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def mouseDoubleClickEvent(self, event):
        self.__toggleMonitoring()
        event.accept()

    def contextMenuEvent(self, event):
        self.__contextMenu.exec_(event.screenPos())

    @property
    def measurement(self):
        return self.__measurement

    @measurement.setter
    def measurement(self, measurement):
        if measurement is None:
            self.setBrush(QBrush(QColor("beige")))
        else:
            self.setBrush(QBrush(QColor("#66ff66")))
        self.__measurement = measurement

def get_dot11_interfaces():
    result = []
    for iface in os.listdir('/sys/class/net'):
        if os.path.exists(os.path.join('/sys/class/net/', iface, 'phy80211')):
            result.append(iface)
    return result

Beacon = collections.namedtuple('Beacon', ['rssi', 'bssid', 'freq', 'ssid'])

class Monitor(QObject):

    MIN_CHANNEL_DWELL_TIME = 100
    MAX_CHANNEL_DWELL_TIME = 5000

    started = pyqtSignal()
    stopped = pyqtSignal(bool)

    def __init__(self, interface, *args):
        QObject.__init__(self, *args)

        self.__iface = interface

        self.__process = None
        self.__horst_errfile_path = os.path.join(_tmpdir, 'horst.err')
        self.__horst_outfile_path = os.path.join(_tmpdir, 'horst.out')
        self.__horst_configfile_path = os.path.join(_tmpdir, 'horst.conf')

        self.setChannelDwellTime(500)

    def channelDwellTime(self):
        return self.__dwell

    def setChannelDwellTime(self, millisecs):
        self.__dwell = max(Monitor.MIN_CHANNEL_DWELL_TIME,
                           min(millisecs, Monitor.MAX_CHANNEL_DWELL_TIME))

    def interface(self):
        return self.__iface

    def setInterface(self, interface):
        self.__iface = interface

    def start(self):
        if self.__process is not None:
            return False

        self.__process = QProcess(self)
        self.__process.setStandardErrorFile(self.__horst_errfile_path)

        self.__process.started.connect(self.started)
        self.__process.finished.connect(self.__emitStopped)

        with open(self.__horst_configfile_path, 'w') as f:
            f.write('quiet\n')
            f.write('interface = {}\n'.format(self.__iface))
            f.write('filter_packet = BEACON\n')
            f.write('channel_upper = 48\n')
            f.write('channel_dwell = {}\n'.format(self.__dwell))
            f.write('channel = 1\n')
            f.write('channel_scan\n')
            f.write('channel_scan_rounds = 1\n')
            f.write('outfile = {}\n'.format(self.__horst_outfile_path))

        args = ['-c', self.__horst_configfile_path]

        self.__process.start("%s-horst" % os.path.abspath(__file__), args,
                             QIODevice.ReadOnly)

        return True

    def errorText(self):
        with open(self.__horst_errfile_path) as errfile:
            return errfile.read()

    def __emitStopped(self, exitCode, exitStatus):
        if exitStatus == QProcess.CrashExit:
            self.stopped.emit(False)
        else:
            self.stopped.emit(not bool(exitCode))

    def terminate(self):
        if self.__process:
            self.__process.close()
            self.__process = None

    def readBeacons(self):
        result = []

        with open(self.__horst_outfile_path) as f:
            f.readline() # Ignore header
            for line in f:
                fields = [s.strip() for s in line.strip().split(',')]
                bssid = fields[4]
                rssi = fields[6]
                freq = fields[9]
                ssid = fields[11]

                result.append(Beacon(rssi=int(rssi), bssid=bssid,
                                     freq=int(freq), ssid=ssid))

        return result

class MonitorWidget(QWidget):

    def __init__(self, monitor, *args):
        QWidget.__init__(self, *args)

        self.__monitor = monitor
        self.__monitor.started.connect(self.__disable)
        self.__monitor.stopped.connect(self.__enable)

        layout = QVBoxLayout()
        formLayout = QFormLayout()

        self.__ifaceComboBox = QComboBox()
        self.__ifaceComboBox.addItems(sorted(INTERFACES))
        self.__ifaceComboBox.setCurrentIndex(len(INTERFACES) - 1)
        self.__ifaceComboBox.activated.connect(self.__saveInterface)
        formLayout.addRow("Interface:", self.__ifaceComboBox)

        self.__dwellSpinBox = QSpinBox()
        self.__dwellSpinBox.setSuffix("ms")
        self.__dwellSpinBox.setMinimum(Monitor.MIN_CHANNEL_DWELL_TIME)
        self.__dwellSpinBox.setMaximum(Monitor.MAX_CHANNEL_DWELL_TIME)
        self.__dwellSpinBox.setSingleStep(50)
        self.__dwellSpinBox.setValue(monitor.channelDwellTime())
        self.__dwellSpinBox.valueChanged.connect(self.__saveDwell)

        dwellWhatsThis = """
        <p>

        <i>Channel dwell time</i> defines the time (in milliseconds) the
        monitor stays on one channel while it is measuring and hopping channels.

        </p>

        <p>

        The longer the dwell time the more complete the set of found BSS IDs,
        because the monitor has more chances to hear beacons. To maximize the
        chances of hearing beacons from all surrounding APs, the channel dwell
        time should be set a bit higher than the shortest expected beacon
        interval.

        </p>"""

        self.__dwellSpinBox.setWhatsThis(dwellWhatsThis)
        dwellLabel = QLabel("Channel dwell time:")
        dwellLabel.setWhatsThis(dwellWhatsThis)
        formLayout.addRow(dwellLabel, self.__dwellSpinBox)

        self.__statusLabel = QLabel("Ready")
        formLayout.addRow("Status:", self.__statusLabel)

        layout.addLayout(formLayout)
        self.__view = ZoomableGraphicsView(self)
        self.__view.setRenderHints(QPainter.Antialiasing)
        layout.addWidget(self.__view)

        self.setLayout(layout)

    def setScene(self, scene):
        self.__view.setScene(scene)

    def __disable(self):
        self.__statusLabel.setTextInteractionFlags(Qt.NoTextInteraction)
        self.__statusLabel.setText("Scanning...")
        self.__ifaceComboBox.setEnabled(False)
        self.__dwellSpinBox.setEnabled(False)

    def __enable(self, isSuccess):
        if isSuccess:
            self.__statusLabel.setTextInteractionFlags(Qt.NoTextInteraction)
            self.__statusLabel.setText("Ready")
        else:
            self.__statusLabel.setTextInteractionFlags(Qt.TextSelectableByMouse)
            self.__statusLabel.setText(self.__monitor.errorText())
        self.__ifaceComboBox.setEnabled(True)
        self.__dwellSpinBox.setEnabled(True)

    def __saveInterface(self):
        self.__monitor.setInterface(self.__ifaceComboBox.currentText())

    def __saveDwell(self, value):
        self.__monitor.setChannelDwellTime(value)

class MainWindow(QMainWindow):

    def __init__(self, monitor, *args):
        QMainWindow.__init__(self, *args)

        self.__monitor = monitor

        self.__monitorScene = None

        self.setWindowTitle("Puavo WLAN Mapper")

        view = ZoomableGraphicsView(self)
        view.setRenderHints(QPainter.Antialiasing)
        self.setCentralWidget(view)

        self.__setupDockWidgets()
        self.__setupActions()
        self.__setupMenus()

    def closeEvent(self, event):
        self.__monitor.terminate()

    def sizeHint(self):
        return QSize(800, 600)

    def __setupActions(self):
        self.__aboutAction = QAction(self)
        self.__aboutAction.setText("&About...")
        self.__aboutAction.triggered.connect(self.__showAboutDialog)

        self.__newProjectAction = QAction(self)
        self.__newProjectAction.setText("&New project...")
        self.__newProjectAction.setShortcut(QKeySequence("Ctrl+N"))
        self.__newProjectAction.triggered.connect(self.__newProjectDialog)

        self.__saveProjectAsAction = QAction(self)
        self.__saveProjectAsAction.setText("&Save project as...")
        self.__saveProjectAsAction.setShortcut(QKeySequence("Ctrl+S"))
        self.__saveProjectAsAction.triggered.connect(self.__saveProjectAsDialog)
        self.__saveProjectAsAction.setEnabled(False)

        self.__openProjectAction = QAction(self)
        self.__openProjectAction.setText("&Open project...")
        self.__openProjectAction.setShortcut(QKeySequence("Ctrl+O"))
        self.__openProjectAction.triggered.connect(self.__openProjectDialog)

        self.__quitAction = QAction(self)
        self.__quitAction.setText("&Quit")
        self.__quitAction.setShortcut(QKeySequence("Ctrl+Q"))
        self.__quitAction.triggered.connect(self.close)

        self.__whatsThisAction = QWhatsThis.createAction()

    def __setupMenus(self):
        menuBar = QMenuBar()

        fileMenu = menuBar.addMenu("&File")
        fileMenu.addAction(self.__newProjectAction)
        fileMenu.addAction(self.__openProjectAction)
        fileMenu.addAction(self.__saveProjectAsAction)
        fileMenu.addSeparator()
        fileMenu.addAction(self.__quitAction)

        viewMenu = menuBar.addMenu("&View")
        viewMenu.addAction(self.__monitorDockWidget.toggleViewAction())

        helpMenu = menuBar.addMenu("&Help")
        helpMenu.addAction(self.__whatsThisAction)
        helpMenu.addAction(self.__aboutAction)

        self.setMenuBar(menuBar)

    def __setupDockWidgets(self):
        self.__monitorDockWidget = QDockWidget(self)
        self.__monitorWidget = MonitorWidget(self.__monitor, self)
        self.__monitorDockWidget.setWidget(self.__monitorWidget)
        self.__monitorDockWidget.setWindowTitle("Monitor")
        self.addDockWidget(Qt.LeftDockWidgetArea, self.__monitorDockWidget)

    def __openProjectDialog(self):
        filepath = QFileDialog.getOpenFileName(None,
                                               "Open a project",
                                               QDir.currentPath(),
                                               "Compressed Tar archives (*.tar.gz)")
        if not filepath:
            return

        self.__monitorScene = MonitorScene(self.__monitor)
        self.__saveProjectAsAction.setEnabled(True)
        self.__monitorWidget.setScene(self.__monitorScene)
        self.__monitor.terminate()

        with tarfile.open(unicode(filepath), "r:gz") as archive_file:

            src_image = archive_file.extractfile("scene/layout.png")
            with open(os.path.join(_tmpdir, "layout.png"), "wb") as dst_image:
                shutil.copyfileobj(src_image, dst_image)
            self.__monitorScene.setLayoutPixmap(QPixmap(os.path.join(_tmpdir, "layout.png")))

            essids_picklefile = archive_file.extractfile("scene/essids.pickle")
            self.__monitorScene.essids = pickle.load(essids_picklefile)

            spots_picklefile = archive_file.extractfile("scene/spots.pickle")
            self.__monitorScene.setSpotData(pickle.load(spots_picklefile))

    def __saveProjectAsDialog(self):
        filepath = QFileDialog.getSaveFileName(None,
                                               "Save the project as",
                                               QDir.currentPath(),
                                               "Compressed Tar archives (*.tar.gz)")
        filepath = str(filepath)
        if not filepath:
            return

        if not str(filepath).endswith('.tar.gz'):
            filepath = '%s.tar.gz' % filepath

        scenedir = os.path.join(_tmpdir, "scene")
        try:
            shutil.rmtree(scenedir)
        except OSError, e:
            if e.errno != errno.ENOENT:
                raise e
        os.mkdir(scenedir)

        with open(os.path.join(scenedir, "spots.pickle"), "w") as f:
            pickle.dump(self.__monitorScene.spotData(), f)

        with open(os.path.join(scenedir, "essids.pickle"), "w") as f:
            pickle.dump(self.__monitorScene.essids, f)

        shutil.copy(os.path.join(_tmpdir, "layout.png"), scenedir)

        with tarfile.open(unicode(filepath), "w:gz") as f:
            f.add(scenedir, "scene")

    def __newProjectDialog(self):
        dialog = NewProjectDialog()
        if not dialog.exec_():
            return

        filepath = dialog.layoutImageFilePath()

        layoutPixmap = QPixmap(filepath, "png")
        if layoutPixmap.isNull():
            msg = "File {} could not be loaded as a layout image.\n\n" \
                  "Please ensure the layout image is a valid PNG file."
            QMessageBox.critical(self, "Failed to load a layout image",
                                 msg.format(filepath))
        else:
            shutil.copy(filepath, os.path.join(_tmpdir, "layout.png"))
            self.__monitorScene = MonitorScene(self.__monitor)
            self.__monitorScene.setLayoutPixmap(layoutPixmap)
            self.__saveProjectAsAction.setEnabled(True)
            self.__monitorWidget.setScene(self.__monitorScene)
            self.__monitor.terminate()

    def __showAboutDialog(self):
        aboutText = QString.fromUtf8(
            "<h1>Puavo WLAN Mapper</h1>"
            "<p>Copyright © 2015 <a href=\"http://opinsys.fi\">Opinsys Oy</a></p>"
            "<p>This program is free software: you can redistribute it and/or "
            "modify it under the terms of the GNU General Public License as "
            "published by the Free Software Foundation, either version 2 of the "
            "License, or (at your option) any later version.</p>"
            "<p>This program is distributed in the hope that it will be useful, but"
            " WITHOUT ANY WARRANTY; without even the implied warranty of "
            "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>"
            "<p>See the <a href=\"https://www.gnu.org/licenses/gpl-2.0.html\">GNU "
            "General Public License</a> for more details.</p>")

        QMessageBox.about(self, "About Puavo WLAN Mapper", aboutText)

class NewProjectDialog(QDialog):

    def __init__(self, *args):
        QDialog.__init__(self, *args)

        self.setModal(True)
        self.setWindowTitle("Create a new project")

        imageLineEdit = QLineEdit()
        imageLineEdit.textChanged.connect(self.__checkImageFilePath)
        browseButton = QPushButton("&Browse")
        browseButton.clicked.connect(self.__getLayoutImageFileName)

        cancelButton = QPushButton("&Cancel")
        cancelButton.clicked.connect(self.reject)
        createButton = QPushButton("Create")
        createButton.clicked.connect(self.accept)
        createButton.setEnabled(False)

        layout = QVBoxLayout(self)
        formLayout = QFormLayout()
        browseLayout = QHBoxLayout()
        buttonLayout = QHBoxLayout()

        browseLayout.addWidget(imageLineEdit)
        browseLayout.addWidget(browseButton)

        formLayout.addRow("Layout image:", browseLayout)

        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(createButton)

        layout.addLayout(formLayout)
        layout.addLayout(buttonLayout)

        self.__imageLineEdit = imageLineEdit
        self.__createButton = createButton

    def layoutImageFilePath(self):
        return self.__imageLineEdit.text()

    def __checkImageFilePath(self):
        self.__createButton.setEnabled(os.path.isfile(self.__imageLineEdit.text()))

    def __getLayoutImageFileName(self):
        filepath = QFileDialog.getOpenFileName(None,
                                               "Load layout image",
                                               QDir.currentPath(),
                                               "Images (*.png)")
        if filepath:
            self.__imageLineEdit.setText(filepath)

    def sizeHint(self):
        s = QDialog.sizeHint(self)
        return QSize(s.width() + self.__imageLineEdit.sizeHint().width() * 2, s.height())

INTERFACES = get_dot11_interfaces()

def main():
    global _tmpdir
    try:
        _tmpdir = tempfile.mkdtemp(prefix='puavo-wlanmapper.')
        app = QApplication(sys.argv)

        if app.argc() > 1:
            error_message = "ERROR: invalid number of arguments ({})"
            print(error_message.format(app.argc() - 1), file=sys.stderr)
            print("Usage: {}".format(sys.argv[0]), file=sys.stderr)
            return 1

        if not INTERFACES:
            QMessageBox.critical(None, "Startup failure", "Failed to find any 802.11 devices.")
            sys.exit(1)

        monitor = Monitor(INTERFACES[0])

        win = MainWindow(monitor)
        win.show()

        sys.exit(app.exec_())
    finally:
        if _tmpdir:
            shutil.rmtree(_tmpdir)

if __name__ == "__main__":
    main()
