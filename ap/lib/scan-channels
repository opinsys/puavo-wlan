#!/bin/sh

## Print supported channels, one per line, sorted by the measured signal
## level in ascending order, e.g. the channel with weakest signal is
## listed first. List of channels and their signal levels are based on
## iwlist scan results.

## Usage: scan-channels [CHANNEL...]

set -eu

supported_channels=$*

## Scan APs and consider only the first four lines from each result item:
##          Cell 11 - Address: 20:BB:C0:C8:34:F0
##                    Channel:11
##                    Frequency:2.462 GHz (Channel 11)
##                    Quality=21/70  Signal level=-89 dBm
iwlist scan 2>/dev/null | egrep -A3 '^\s+Cell [0-9]+ - Address: ' | {

    ## Print all supported channels with artifiaclly low signal levels
    ## to ensure that each supported channel is in the resulting
    ## list. All supported channels not found from the scan results gets
    ## printed first. In other words, free channels are considerd better
    ## than crowded ones. See sort command and the end of this block.
    for supported_channel in ${supported_channels}; do
        printf '%d\t%d\n' -999 ${supported_channel}
    done

    while true; do
        read _                 # Address-line is ignored.
        read channel_line
        read _                 # Frequency-line is ignored.
        read signal_level_line

        channel=$(echo -n "${channel_line}" | sed -rn s'|^Channel:([0-9]+)$|\1|p')
        if [ -z "${channel}" ]; then
            echo "failed to parse channel number" >&2
            exit 1
        fi

        signal_level=$(echo -n "${signal_level_line}" | sed -rn s'|^Quality=[0-9]+/[0-9]+\s+Signal level=(-[0-9]+) dBm.*$|\1|p')
        if [ -z "${signal_level}" ]; then
            echo "failed to parse signal level" >&2
            exit 1
        fi

	if [ -n "${supported_channels}" ]; then
            for supported_channel in ${supported_channels}; do
		if [ "${channel}" = "${supported_channel}" ]; then
                    printf '%s\t%s\n' "${signal_level}" "${channel}"
		fi
            done
	else
	    printf '%s\t%s\n' "${signal_level}" "${channel}"
	fi

        ## grep separates groups of matches with --, break loop on EOF
        read sep || break
        if [ "${sep}" != '--' ]; then
            echo "expected match group separator '--', got '${sep}'" >&2
            exit 1
        fi
    done
} | sort -g -k2 -k1,2 -r | uniq -f1 | sort -g -k1 | cut -f2
