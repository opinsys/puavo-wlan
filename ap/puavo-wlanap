#!/usr/bin/env ruby1.9.1
# coding: utf-8

# = Puavo's Tunneled WLAN Accesspoint
#
# Author    :: Tuomas Räsänen <tuomasjjrasanen@tjjr.fi>
# Copyright :: Copyright (C) 2015 Opinsys Oy
# License   :: GPLv2+
#
# == Usage
#
# Get help:
#   puavo-wlanap --help

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 USA.

# Standard library modules.
require 'digest'
require 'erb'
require 'fileutils'
require 'getoptlong'
require 'pathname'
require 'socket'

begin
  require 'puavo/etc'
  require 'puavo/rest-client'
rescue LoadError
  # Puavo-integration requires aforementioned modules, but puavo-wlanap
  # can still operate without Puavo. This has the same effect as
  # --no-puavo command line option.
  USE_PUAVO = false
else
  USE_PUAVO = true
end

THIS_SCRIPT = Pathname.new($0).realpath

module Dot11

  # Chips handled by following drivers seem to have pretty good chances
  # to work properly.
  SUPPORTED_DRIVERS = ['ath9k', 'rt2800pci', 'rt2800usb']

  BAND_2G = 1
  BAND_5G = 2

  CHANNELS_2G = [ 1,  6, 11]
  CHANNELS_5G = [36, 40, 44, 48]

  CHANNELS = {
    BAND_2G           => CHANNELS_2G,
    BAND_5G           => CHANNELS_5G,
    BAND_2G | BAND_5G => CHANNELS_2G + CHANNELS_5G,
  }

  def self.get_interface_driver(iface)
    File.open(File.join('/sys/class/net', iface, 'device', 'uevent')) do |file|
      file.each_line do |line|
        next unless /^DRIVER=(.*)$/ =~ line
        return $1
      end
    end
    nil
  end

  def self.has_supported_driver(iface)
    driver = Dot11.get_interface_driver(iface)
    Dot11::SUPPORTED_DRIVERS.include?(driver)
  end

  def self.is_wlan_interface(iface)
    File.open(File.join('/sys/class/net', iface, 'uevent')) do |file|
      file.each_line do |line|
        return true if /^DEVTYPE=wlan$/ =~ line
      end
    end
    false
  end

  def self.each_interface
    Dir.glob('/sys/class/net/*') do |path|
      iface = File.basename(path)
      next unless Dot11.is_wlan_interface(iface)
      next unless Dot11.has_supported_driver(iface)
      yield iface
    end
  end

  def self.get_band(iface)
    hw_mode = IO.popen(['iwconfig', iface]) do |io|
      io.gets =~ /^.* IEEE 802.11([a-z]+).*$/
      break $1
    end
    raise 'failed to query supported bands' unless $?.success?

    band = 0
    band |= Dot11::BAND_5G if hw_mode.include?('a')
    band |= Dot11::BAND_2G if hw_mode.include?('g')

    band
  end

  def self.get_bssid(iface)
    sysdir = "/sys/class/net/#{iface}"
    phydir = "#{sysdir}/phy80211"
    devdir = "#{sysdir}/device"

    addr = File.read("#{phydir}/macaddress"  ).split(':').map { |v| v.to_i(16) }
    mask = File.read("#{phydir}/address_mask").split(':').map { |v| v.to_i(16) }

    uevent = File.read("#{devdir}/uevent")
    uevent =~ /^PRODUCT=(.+)\/(.+)\/.*$/ or uevent =~ /^PCI_ID=(.+):(.+)$/

    model_id = "%04x%04x" % [$1.to_i(16), $2.to_i(16)]

    ## For some reason, at least with some driver versions, these device
    ## models report empty address masks. However, hostapd requires that
    ## mask >= 00:00:00:00:00:03 to support at most 4 different
    ## BSSIDs. Mask 00:00:00:00:00:03 has been verified to work with
    ## devices in question.
    if ['168c0030', '168c002b', '168c0037'].include?(model_id) then
      if mask.map { |v| v == 0 } .all? then
        mask = [0x00, 0x00, 0x00, 0x00, 0x00, 0x03]
      end
    end

    addr.zip(mask).map { |(a, b)| "%02x" % (a &~ b) } .join(":")
  end

  def self.get_ht_capab(iface, channel)
    phyname = File.read("/sys/class/net/#{iface}/phy80211/name").strip

    is_ht20sgi_capab = IO.popen(['iw', phyname, 'info']) do |io|
      !io.grep(/^\s+RX HT20 SGI.*$/).empty?
    end
    $?.success? or raise 'failed to query HT capabilities'

    case channel
    when 1, 6
      is_ht20sgi_capab ? '[HT20][SHORT-GI-20]' : '[HT40+]'
    when 11
      is_ht20sgi_capab ? '[HT20][SHORT-GI-20]' : '[HT40-]'
    when 36, 44
      '[HT40+]'
    when 40, 48
      '[HT40-]'
    else
      raise "unsupported channel #{channel}"
    end
  end

  def self.scan(iface, band)
    # Prime results with worst possible signal levels.
    results = {}
    Dot11::CHANNELS[band].each { |ch| results[ch] = -999 }

    IO.popen(['iwlist', iface, 'scan']) do |io|
      io.each_line do |line|
        next unless line =~ /^\s+Cell [0-9]+ - Address: .*$/

        io.readline.strip =~ /^Channel:([0-9]+)$/
        channel = $1.to_i

        io.readline.strip # Ignore frequency line.

        io.readline.strip =~ /^Quality=[0-9]+\/[0-9]+\s+Signal level=(-[0-9]+) dBm.*$/
        signal_level = $1.to_i

        if results.has_key?(channel)
          results[channel] = signal_level if results[channel] < signal_level
        end
      end
    end
    $?.success? or raise "failed to scan with interface #{iface}"

    # Return channels in ascending signal level order.
    Hash[results.sort_by { |channel, signal_level| signal_level }].keys
  end

end

# Default runtime directory, use --rundir to override.
RUNDIR       = '/run/puavo-wlanap'

# Default vtun server address, use --vtun-address to override.
VTUN_ADDRESS = 'wlangw'

# Default vtun server port, use --vtun-port to override.
VTUN_PORT    = 45045

BACKHAULS    = [:single, :vtun]

HOSTAPD_CONF_TEMPLATE = <<'EOF'
## PHY-specific options ##
interface=<%= phy[:iface] %>
bssid=<%= phy[:bssid] %>
driver=nl80211
country_code=FI
hw_mode=<%= phy[:hw_mode] %>
channel=<%= phy[:channel] %>
max_num_sta=1000
wmm_enabled=1
ctrl_interface=<%= rundir %>/hostapd
ieee80211n=1
ht_capab=<%= phy[:ht_capab] %>
wds_sta=1
<% for bss in bss_list %>

## BSS-specific options ##
<% if bss[:index] > 0 %>
bss=<%= phy[:iface] %>_<%= bss[:index] %>
<% end %>
ssid=<%= bss[:ssid] %>
bridge=<%= bss[:bridge] %>
<% if bss[:type] == 'open' %>
wpa=0
<% else %>
wpa=2
auth_algs=3
wpa_passphrase=<%= bss[:psk] %>
rsn_pairwise=CCMP
wpa_key_mgmt=WPA-PSK
eapol_version=1
eapol_key_index_workaround=1
eap_reauth_period=0
wpa_strict_rekey=0
wpa_group_rekey=0
wpa_gmk_rekey=0
<% end %>
<% end %>
EOF

VTUND_CONF_TEMPLATE = <<'EOF'
options {
    syslog daemon;
}

puavo-wlanap {
    passwd    wlan;
    type      ether;
    proto     udp;
    speed     0;     # Full speed ahead! Aye aye, captain!
    encrypt   no;
    compress  no;
    multi     yes;

    up {
        program "<%= THIS_SCRIPT %> --rundir '<%= rundir %>' --ctrlmsg 'vtun-up:%%:<%= bss[:bridge] %>'";
    };

    down {
        program "<%= THIS_SCRIPT %> --rundir '<%= rundir %>' --ctrlmsg 'vtun-down:%%:<%= bss[:bridge] %>'";
    };
}
EOF

def get_default_interface()
  File.open('/proc/net/route') do |route_file|
    route_file.readline # Ignore the first header line.

    route_file.each_line do |line|
      fields = line.strip.split

      interface   = fields[0]
      destination = fields[1].to_i(16)
      flags       = fields[3].to_i(16)

      next unless flags & 1 # Is up.
      next unless destination == 0 # Is default.

      return interface
    end

  end
  nil
end

def get_nets_from_puavo
  nets_wait = 1
  while true
    client = PuavoRestClient.new
    response = client.get("/v3/devices/#{PUAVO_ETC.hostname}/wlan_networks")

    nets = response.parse.select { |net| net['wlan_ap'] } .each do |net|
      # Magic SSID Mangling! The following Magic SSID is substituted
      # with a SSID derived from the hostname. This lets us configure
      # AP-specific networks easily via Puavo.
      next unless net['ssid'] =~ /^le8Yuek9Some5ee$/
      net['ssid'] = PUAVO_ETC.hostname.tr(' ', '')
    end

    return nets unless nets.empty?

    nets_wait = [nets_wait * 2, 3600].min
    sleep nets_wait
  end
end

def hexdigest15(str)
  md5sum = Digest::MD5.new
  md5sum << str
  md5sum.hexdigest[0..14]
end

def run_or_fail(cmd, *args)
  system(cmd, *args)
  $?.success? or raise "command '%s' failed" % ([cmd] + args).join(' ')
end

def fill_phy_list(phy_list, band)
  Dot11.each_interface do |iface|
    next unless band == Dot11.get_band(iface)
    run_or_fail('ifconfig', iface, 'up')
    best_channels = Dot11.scan(iface, band)
    free_channels = best_channels - phy_list.map { |phy| phy[:channel] }
    next if free_channels.empty?
    channel = free_channels[0]

    phy_list << {
      :iface    => iface,
      :channel  => channel,
      :bssid    => Dot11.get_bssid(iface),
      :hw_mode  => Dot11::CHANNELS_5G.include?(channel) ? 'a' : 'g',
      :ht_capab => Dot11.get_ht_capab(iface, channel),
    }
  end
end

def get_phy_list
  phy_list = []

  fill_phy_list(phy_list, Dot11::BAND_5G)
  fill_phy_list(phy_list, Dot11::BAND_2G)
  fill_phy_list(phy_list, Dot11::BAND_5G | Dot11::BAND_2G)

  phy_list
end

def get_bss_list(use_puavo, nets)
  if use_puavo
    nets.concat(get_nets_from_puavo)
  end

  # At most 4 BSSes are supported.
  nets.slice!(4..-1)

  nets.length.times.zip(nets).map do |i, net|
    {
      :index  => i,
      :bridge => hexdigest15(net['ssid']),
      :psk    => net['password'],
      :type   => net['type'],
      :ssid   => net['ssid'],
    }
  end
end

def write_conf(rundir, filename, conf)
  File.open(File.join(rundir, filename), 'w', 0640) do |file|
    file.write(conf)
  end
end

def write_hostapd_conf(phy_list, bss_list, rundir)
  phy_list.each do |phy|
    bss_list.each do |bss|
      conf = ERB.new(HOSTAPD_CONF_TEMPLATE, 3, '<>').result(binding)
      write_conf(rundir, "hostapd_#{phy[:iface]}.conf", conf)
    end
  end
end

def write_vtund_conf(bss_list, rundir)
  bss_list.each do |bss|
    conf = ERB.new(VTUND_CONF_TEMPLATE, 3, '<>').result(binding)
    write_conf(rundir, "vtund_#{bss[:bridge]}.conf", conf)
  end
end

def spawn_dhclient(iface)
  spawn('dhclient', '-d', bss[:bridge])
end

def start_services(critical_service_pids, phy_list, bss_list, rundir,
                   vtun_address, vtun_port, backhaul, bh_iface)
  bss_list.each do |bss|
    run_or_fail('brctl', 'addbr', bss[:bridge])
    run_or_fail('brctl', 'setfd', bss[:bridge], '0')
    run_or_fail('ifconfig', bss[:bridge], 'up')

    if backhaul == :single
      run_or_fail('brctl', 'addif', bss[:bridge], bh_iface)
      critical_service_pids << spawn_dhclient(bss[:bridge])
    end

    if backhaul == :vtun
      vtund_conffile = File.join(rundir, "vtund_#{bss[:bridge]}.conf")
      critical_service_pids << spawn('vtund', '-n', '-P', vtun_port.to_s,
                                     '-f', vtund_conffile,
                                     'puavo-wlanap', vtun_address)
    end
  end

  # Magical sleep to "ensure" that bridges and tunnels are all set
  # before proceeding.
  sleep 8

  phy_list.each do |phy|

    # Try to disable power saving, because it seems to cause flaky
    # connection quality in some scenarios.
    system('iw', 'dev', phy[:iface], 'set', 'power_save', 'off')

    hostapd_pidfile = File.join(rundir, "hostapd_#{phy[:iface]}.pid")
    hostapd_conffile = File.join(rundir, "hostapd_#{phy[:iface]}.conf")
    critical_service_pids << spawn('hostapd', '-P', hostapd_pidfile,
                                   hostapd_conffile)
  end
end

def run(kwargs = {})
  backhaul     = kwargs.fetch(:backhaul,     BACKHAULS[0])
  bh_iface     = kwargs.fetch(:bh_iface,     get_default_interface)
  ctrlmsg      = kwargs.fetch(:ctrlmsg,      nil)
  nets         = kwargs.fetch(:nets,         [])
  use_puavo    = kwargs.fetch(:use_puavo,    USE_PUAVO)
  rundir       = kwargs.fetch(:rundir,       RUNDIR)
  vtun_address = kwargs.fetch(:vtun_address, VTUN_ADDRESS)
  vtun_port    = kwargs.fetch(:vtun_port,    VTUN_PORT)

  critical_service_pids = []
  phy_list              = []
  bss_list              = []

  if !ctrlmsg.nil?
    ctrl = UNIXSocket.new(File.join(rundir, 'ctrlsocket'))
    ctrl.puts(ctrlmsg)
    exit(0)
  end

  Signal.trap('EXIT') do
    Process.kill('-SIGTERM', 0)

    bss_list.each do |bss|
      # Ignore errors, we are already exiting.
      system('ifconfig', bss[:bridge], 'down')
      system('brctl', 'delbr', bss[:bridge])
    end

    FileUtils.rm_rf(rundir)
  end

  FileUtils.mkdir_p(rundir)

  phy_list.concat(get_phy_list)
  bss_list.concat(get_bss_list(use_puavo, nets))

  write_hostapd_conf(phy_list, bss_list, rundir)
  write_vtund_conf(bss_list, rundir)

  [:HUP, :USR1, :USR2].each { |s| Signal.trap(s, 'SIG_IGN') }

  sigqueue = []
  sigpipe_r, sigpipe_w = IO.pipe

  [:CHLD, :INT, :QUIT, :TERM].each do |signal|
    Signal.trap(signal) do
      sigpipe_w.write_nonblock('o')
      sigqueue << signal
    end
  end

  serv = UNIXServer.new(File.join(rundir, 'ctrlsocket'))
  conn = nil

  start_services(critical_service_pids,
                 phy_list, bss_list, rundir,
                 vtun_address, vtun_port, backhaul, bh_iface)

  loop do
    case sigqueue.pop
    when :INT
    when :QUIT
    when :TERM
      exit(1)
    when :CHLD
      begin
        child_pid = Process.wait(0, Process::WNOHANG)
      rescue SystemCallError => e
        raise e unless e.errno == Errno::ECHILD
      end
      if critical_service_pids.include?(child_pid)
        # We have lost a critical service, time to exit.
        exit(1)
      end
    else
      ready = IO.select([sigpipe_r, conn.nil? ? serv : conn], [], [], 5)

      if ready.nil?
        if !conn.nil?
          STDERR.puts('control socket connection timeout')
          conn.close
          conn = nil
        end
        next
      end

      if ready[0].include?(sigpipe_r)
        sigpipe_r.read_nonblock(1)
      end

      if ready[0].include?(serv)
        conn = serv.accept
      end

      if ready[0].include?(conn)
        begin
          line = conn.readline
        rescue EOFError
          STDERR.puts('WARNING: received invalid control message')
        else
          line.strip!
          cmd, sep, args = line.partition ':'
          case cmd
          when 'vtun-up'
            iface, *bridge = args.split ':'
            if bridge.length == 1
              bridge = bridge[0]
              run_or_fail('ifconfig', iface, 'up')
              run_or_fail('brctl', 'addif', bridge, iface)
              critical_service_pids << spawn_dhclient(bridge)
            else
              STDERR.puts("WARNING: received invalid vtun-up command: #{line}")
            end
          else
            STDERR.puts("WARNING: received unknown control message: #{line}")
          end
        ensure
          conn.close
          conn = nil
        end
      end
    end
  end
end

def main
  run_kwargs = {}

  GetoptLong.new(
    ['--backhaul'                  , GetoptLong::REQUIRED_ARGUMENT],
    ['--backhaul-single-interface' , GetoptLong::REQUIRED_ARGUMENT],
    ['--backhaul-vtun-address'     , GetoptLong::REQUIRED_ARGUMENT],
    ['--backhaul-vtun-port'        , GetoptLong::REQUIRED_ARGUMENT],
    ['--help', '-h'                , GetoptLong::NO_ARGUMENT],
    ['--network-open'              , GetoptLong::REQUIRED_ARGUMENT],
    ['--no-puavo'                  , GetoptLong::NO_ARGUMENT],
    ['--rundir'                    , GetoptLong::REQUIRED_ARGUMENT],

    # For internal use only.
    ['--ctrlmsg', GetoptLong::REQUIRED_ARGUMENT],
  ).each do |opt, arg|
    case opt
    when '--backhaul'
      case arg
      when :vtun.to_s
        run_kwargs[:backhaul] = :vtun
      when :single.to_s
        run_kwargs[:backhaul] = :single
      else
        STDERR.puts("ERROR: invalid backhaul mode (#{arg})")
        exit(1)
      end

    when '--backhaul-single-interface'
      run_kwargs[:bh_iface] = arg

    when '--backhaul-vtun-address'
      run_kwargs[:vtun_address] = arg

    when '--backhaul-vtun-port'
      unless arg =~ /^[1-9][0-9]*$/ then
        STDERR.puts("ERROR: invalid port number (#{arg})")
        exit(1)
      end
      run_kwargs[:vtun_port] = arg.to_i

    when '--help'
      puts <<EOF
Usage: puavo-wlanap [OPTION]...

Tunneled WLAN accesspoint.

Options:
     --backhaul [#{BACKHAULS.join '|' }]
         Set the backhaul type, default: #{BACKHAULS[0]}.

         single

           Use an existing network interface as the backhaul by adding
           it to the BSS bridge.

           This option requires following options:

             --backhaul-single-interface INTERFACE

         vtun

           Create per-BSS 802.3 (Ethernet) tunnels over UDP and use them
           as backhauls.

           This option requires following options:

             --backhaul-vtun-address ADDRESS
             --backhaul-vtun-port    PORT

     --backhaul-single-interface INTERFACE
         Use INTERFACE as the backhaul network interface instead of the
         default route interface.

     --backhaul-vtun-address ADDRESS
         Set the address of the vtun server.

     --backhaul-vtun-port PORT
         Set the port of the vtun server.

 -h, --help
         Display this help and exit.

     --network-open SSID
         Create an open network with the given SSID.

     --no-puavo
         Disable all Puavo-extensions.

     --rundir DIR
         Set the runtime directory, default: #{RUNDIR}

EOF
      exit(0)

    when '--network-open'
      nets = run_kwargs[:nets] = run_kwargs.fetch(:nets, [])
      nets << {
        'type'     => 'open',
        'ssid'     => arg,
        'password' => '',
      }

    when '--no-puavo'
      run_kwargs[:use_puavo] = false

    when '--rundir'
      run_kwargs[:rundir] = arg

    when '--ctrlmsg'
      run_kwargs[:ctrlmsg] = arg

    end
  end

  if ARGV.length != 0 then
    STDERR.puts("ERROR: invalid number of arguments (#{ARGV.length}), expected 0")
    exit(1)
  end

  run(run_kwargs)
end

main
