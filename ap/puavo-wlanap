#!/bin/bash

set -eubm

on_exit()
{
    local -r exitval=$?
    local net ssid

    ## Do not exit or terminate on error or signal anymore. We are
    ## already exiting and it would be shame to exit while exiting, yo
    ## dawg.
    set +eu
    trap '' EXIT HUP INT QUIT ABRT ALRM TERM USR1 USR2

    ## Kill our child processes. There is no reason to let Init adopt
    ## them when puavo-wlanap dies.
    pkill -TERM -P $$

    ## Burn the bridges.
    for net in "${PWAP_NETS[@]}"; do
        IFS=':' read _ ssid _ <<<"${net}"
        ifconfig "${ssid}" down
        brctl delbr "${ssid}"
    done

    rm -rf "${PWAP_RUNDIR}"

    exit $exitval
}

write_hostapd_conf()
{
    local radio channel iface ssid_count bssid net auth ssid psk

    ## Configure one hostapd per radio.
    for radio in "${PWAP_RADIOS[@]}"; do
        IFS=':' read channel iface <<<"${radio}"
        ssid_count=0
        bssid=$("${PWAP_LIBDIR}/get-bssid" "${iface}")

        [ -n "${bssid}" ] || {
            pwap_log "failed to find the first address in the block"
            return 1
        }

        ## Write interface-specific hostapd configuration to the
        ## beginning of the file.
        sed -e "s|#{PWAP_IFACE}|${iface}|g" \
            -e "s|#{PWAP_BSSID}|${bssid}|g" \
            -e "s|#{PWAP_RUNDIR}|${PWAP_RUNDIR}|g" \
            "${PWAP_DATADIR}/hostapd.conf.${channel}" \
            >"${PWAP_RUNDIR}/${iface}_hostapd.conf"

        for net in "${PWAP_NETS[@]}"; do
            IFS=':' read auth ssid psk <<<"${net}"

            ## Append network-specific hostapd configuration to the end.
            cat "${PWAP_DATADIR}/${auth}_hostapd.conf" \
                >>"${PWAP_RUNDIR}/${iface}_hostapd.conf"
            sed -i \
                -e "s|#{PWAP_BSS}|${iface}_${ssid_count}|g" \
                -e "s|#{PWAP_SSID}|${ssid}|g" \
                -e "s|#{PWAP_PSK}|${psk}|g" \
                "${PWAP_RUNDIR}/${iface}_hostapd.conf"
            ssid_count=$((ssid_count + 1))
        done
    done
}

write_vtund_conf()
{
    local net ssid session

    ## Configure one vtund client per network.
    for net in "${PWAP_NETS[@]}"; do
        IFS=':' read _ ssid _ <<<"${net}"

        if [ ${PWAP_LEGACY_MODE} -eq 0 ]; then
            session="${ssid}"
        else
            session="puavo-wlanap"
        fi

        sed -e "s|#{PWAP_LIBDIR}|${PWAP_LIBDIR}|g" \
            -e "s|#{PWAP_SSID}|${ssid}|g" \
            -e "s|#{PWAP_RUNDIR}|${PWAP_RUNDIR}|g" \
            -e "s|#{PWAP_SESSION}|${session}|g" \
            "${PWAP_DATADIR}/vtund.conf" \
            >"${PWAP_RUNDIR}/${ssid}_vtund.conf"
    done
}

setup_nets()
{
    local net auth ssid psk ap_ssid

    "${PWAP_LIBDIR}/fetch-nets" >"${PWAP_RUNDIR}/nets"

    # Magic SSID Mangling! The following Magic SSID is substituted with
    # a SSID derived from the hostname. This lets us configure
    # AP-specific networks easily via Puavo.
    ap_ssid=$(hostname | tr -d [:space:] | tail -c15)
    sed -i -r "s/:le8Yuek9Some5ee:/:${ap_ssid}:/" "${PWAP_RUNDIR}/nets"

    readarray -n4 -t PWAP_NETS <"${PWAP_RUNDIR}/nets"

    if [ ${#PWAP_NETS[@]} -eq 0 ]; then
        pwap_log "no networks defined"
        return 1
    fi

    for net in "${PWAP_NETS[@]}"; do
        IFS=':' read auth ssid psk <<<"${net}"
        case "${auth}" in
            open)
                if [ -n "${psk}" ]; then
                    pwap_log "auth type is 'open', but psk was defined"
                fi
                ;;
            psk)
                if [ "${#psk}" -lt 8 -o "${#psk}" -gt 63 ]; then
                    pwap_log "psk must be 8-63 characters long"
                    return 1
                fi
                ;;
            *)
                pwap_log "unknown auth type '${auth}'"
                return 1
                ;;
        esac
    done

    if [ ${PWAP_LEGACY_MODE} -eq 0 ]; then
        ## Tell gateway which networks we are going to provide.
        for net in "${PWAP_NETS[@]}"; do
            IFS=':' read _ ssid _ <<<"${net}"
            echo "${ssid}" | nc "${PWAP_GWADDR}" "${PWAP_GWPORT_CTRL}"
        done
    fi
}

setup_radios()
{
    local -r channels=(1 6 11 36 40 44 48)
    local i sband_ifaces dband_ifaces iface

    sband_ifaces=$({ "${PWAP_LIBDIR}/find-ifaces" a; "${PWAP_LIBDIR}/find-ifaces" g; } | sort | uniq -u)
    dband_ifaces=$({ "${PWAP_LIBDIR}/find-ifaces" a; "${PWAP_LIBDIR}/find-ifaces" g; } | sort | uniq -d)
    PWAP_RADIOS=()

    i=0
    for iface in ${sband_ifaces}; do
        if [ ${#PWAP_RADIOS[@]} -eq 3 ]; then
            break # Max number of 2.4GHz radios
        fi
        PWAP_RADIOS+=("${channels[i]}:${iface}")
        ((++i))
    done

    i=3 # Start from 5GHz channels.
    for iface in ${dband_ifaces}; do
        if [ ${#PWAP_RADIOS[@]} -eq 7 ]; then
            break # Max number of radios
        fi
        if [ ${#PWAP_RADIOS[@]} -eq 0 ]; then
            PWAP_RADIOS+=("${channels[0]}:${iface}")
            continue
        fi
        PWAP_RADIOS+=("${channels[i]}:${iface}")
        ((++i))
    done
}

setup_services()
{
    setup_nets
    setup_radios
    write_hostapd_conf
    write_vtund_conf
}

start_services()
{
    local net ssid radio iface session

    ## Start one vtund client per network.
    for net in "${PWAP_NETS[@]}"; do
        IFS=':' read _ ssid _ <<<"${net}"

        if [ ${PWAP_LEGACY_MODE} -eq 0 ]; then
            session="${ssid}"
        else
            session="puavo-wlanap"
        fi

        ## Setup the bridge.
        brctl addbr "${ssid}"
        brctl setfd "${ssid}" 0
        ifconfig "${ssid}" up
        dhclient -d "${ssid}" &

        vtund -n -f "${PWAP_RUNDIR}/${ssid}_vtund.conf" \
            -P "${PWAP_GWPORT_DATA}" \
            "${session}" "${PWAP_GWADDR}" &
    done

    ## Magical sleep to "ensure" that bridges and tunnels are all set
    ## before proceeding.
    sleep 8 & wait $!

    ## Start one hostapd per radio.
    for radio in "${PWAP_RADIOS[@]}"; do
        IFS=':' read _ iface <<<"${radio}"
        hostapd -P "${PWAP_RUNDIR}/${iface}_hostapd.pid" \
            "${PWAP_RUNDIR}/${iface}_hostapd.conf" &
    done
}

parse_args()
{
    PWAP_ARGS_DAEMON=0

    if [ $# -eq 1 ]; then
        if [ "$1" = "--daemon" ]; then
            PWAP_ARGS_DAEMON=1
            return 0
        fi
        pwap_log "unexpected argument '$1'"
        echo "Usage: $(basename $0) [--daemon]" >&2
        return 1
    elif [ $# -gt 2 ]; then
        pwap_log "too many arguments"
        echo "Usage: $(basename $0) [--daemon]" >&2
        return 1
    fi
}

report_status()
{
    local -r output=$(hostapd_cli -p "${PWAP_RUNDIR}/hostapd" all_sta)
    local -r devices=$(echo -n "${output}" | sed -n 's/^dot11RSNAStatsSTAAddress=//p' | tr '\n' ',')

    pwap_report <<EOF
wlan_event:hotspot_state
connected_devices:[${devices}]
EOF
}

read_config()
{
    . "${PWAP_DATADIR}/config"

    ## The user might have deleted the configuration file, that's ok.
    [ -r "${PWAP_CONFDIR}/config" ] && . "${PWAP_CONFDIR}/config"
}

## We don't know yet where our data, libs and configs have been
## installed, but we do know that the following script knows it and we do
## know where the following script is (its in PATH!).
. puavo-wlanap-env

## Import library routines.
. "${PWAP_LIBDIR}/common.sh"

read_config

parse_args "$@"

if [ "${PWAP_ARGS_DAEMON}" -ne 0 ]; then
    daemon --noconfig --stderr='daemon.info' --name='puavo-wlanap' -- puavo-wlanap
    exit 0
fi

## After this point the process is getting hot and starts taking actions
## which might have persistent side-effects (files, directories,
## bridges, other processes, etc.). The trap is set to ensure that
## everything gets cleaned up properly afterwards.
trap on_exit EXIT

mkdir -p "${PWAP_RUNDIR}"

setup_services

start_services

## Serve forever.
while true; do
    sleep 3 & wait $!

    ## Keep going even if reporting fails.
    report_status || true
done
