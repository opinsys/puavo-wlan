#!/usr/bin/env ruby1.9.1
# coding: utf-8

# = Puavo's Tunneled WLAN Accesspoint
#
# Author    :: Tuomas Räsänen <tuomasjjrasanen@tjjr.fi>
# Copyright :: Copyright (C) 2015 Opinsys Oy
# License   :: GPLv2+
#
# == Usage
#
# Get help:
#   puavo-wlanap --help

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 USA.

# Standard library modules.
require 'digest'
require 'erb'
require 'fileutils'
require 'getoptlong'
require 'pathname'

# Third-party modules.
require 'puavo/etc'
require 'puavo/rest-client'

THIS_SCRIPT = Pathname.new($0).realpath

# Default runtime directory, use +--rundir+ to override.
DEFAULT_RUNDIR       = '/run/puavo-wlanap'

# Default vtun server address to connect to, use +--vtun-address+ to
# override.
DEFAULT_VTUN_ADDRESS = 'wlangw'

# Default vtun server port to connect to, use +--vtun-port+ to
# override.
DEFAULT_VTUN_PORT    = 45045

BAND_2G = 1
BAND_5G = 2

CHANNELS_2G = [ 1,  6, 11]
CHANNELS_5G = [36, 40, 44, 48]

CHANNELS = {
  BAND_2G           => CHANNELS_2G,
  BAND_5G           => CHANNELS_5G,
  BAND_2G | BAND_5G => CHANNELS_2G + CHANNELS_5G,
}

HOSTAPD_CONF_TEMPLATE = <<'EOF'
## PHY-specific options ##
interface=<%= phy[:iface] %>
bssid=<%= phy[:bssid] %>
driver=nl80211
country_code=FI
hw_mode=<%= phy[:hw_mode] %>
channel=<%= phy[:channel] %>
max_num_sta=1000
wmm_enabled=1
ctrl_interface=<%= rundir %>/hostapd
ieee80211n=1
ht_capab=<%= phy[:ht_capab] %>
wds_sta=1
<% for bss in bss_list %>

## BSS-specific options ##
bss=<%= phy[:iface] %>_<%= bss[:index] %>
bridge=<%= bss[:bridge] %>
<% if bss[:type] == 'open' %>
wpa=0
<% else %>
wpa=2
auth_algs=3
wpa_passphrase=<%= bss[:psk] %>
rsn_pairwise=CCMP
wpa_key_mgmt=WPA-PSK
eapol_version=1
eapol_key_index_workaround=1
eap_reauth_period=0
wpa_strict_rekey=0
wpa_group_rekey=0
wpa_gmk_rekey=0
<% end %>
<% end %>
EOF

VTUND_CONF_TEMPLATE = <<'EOF'
options {
    syslog daemon;
}

puavo-wlanap {
    passwd    wlan;
    type      ether;
    proto     udp;
    speed     0;     # Full speed ahead! Aye aye, captain!
    encrypt   no;
    compress  no;
    multi     yes;

    up {
        program "<%= THIS_SCRIPT %> --vtun-up '%%:<%= bss[:bridge]' %>";
    };

    down {
        program "<%= THIS_SCRIPT %> --vtun-down '%%:<%= bss[:bridge]' %>";
    };
}
EOF

# Return the name of the interface driver.
def get_iface_driver(iface)
  File.open(File.join('/sys/class/net', iface, 'device', 'uevent')) do |file|
    file.each_line do |line|
      next unless /^DRIVER=(.*)$/ =~ line
      return $1
    end
  end
  nil
end

def has_supported_driver(iface)
  driver = get_iface_driver(iface)
  ['ath9k', 'rt2800pci', 'rt2800usb'].include?(driver)
end

# Return boolean indicating whether the interface is a WLAN interface.
def is_wlan_iface(iface)
  File.open(File.join('/sys/class/net', iface, 'uevent')) do |file|
    file.each_line do |line|
      return true if /^DEVTYPE=wlan$/ =~ line
    end
  end
  false
end

def get_band(iface)
  hw_mode = IO.popen(['iwconfig', iface]) do |io|
    io.gets =~ /^.* IEEE 802.11([a-z]+).*$/
    break $1
  end
  raise 'failed to query supported bands' unless $?.success?

  band = 0
  band |= BAND_5G if hw_mode.include?('a')
  band |= BAND_2G if hw_mode.include?('g')

  band
end

# Yield names of interfaces matching the given hardware mode.
def iter_suitable_ifaces(band)
  Dir.glob('/sys/class/net/*') do |path|
    iface = File.basename(path)
    next unless is_wlan_iface(iface)
    next unless has_supported_driver(iface)
    next unless band == get_band(iface)
    yield iface
  end
end

def scan(iface)
  IO.popen(['iwlist', iface, 'scan']) do |io|
    io.each_line do |line|
      next unless line =~ /^\s+Cell [0-9]+ - Address: .*$/

      io.readline.strip =~ /^Channel:([0-9]+)$/
      channel = $1.to_i

      io.readline.strip # Ignore frequency line.

      io.readline.strip =~ /^Quality=[0-9]+\/[0-9]+\s+Signal level=(-[0-9]+) dBm.*$/
      signal_level = $1.to_i

      yield channel, signal_level
    end
  end
  $?.success? or raise "failed to scan with interface #{iface}"
end

def scan_channels(iface, channels)
  # Prime results with worst possible signal levels.
  results = {}
  channels.each { |ch| results[ch] = -999 }

  # Update results with scan results.
  scan iface do |ch, siglvl|
    next unless results.has_key?(ch)
    results[ch] = siglvl if results[ch] < siglvl
  end

  # Return channels in ascending signal level order.
  Hash[results.sort_by { |ch, siglvl| siglvl }].keys
end

def get_nets_from_puavo
  nets_wait = 1
  while true
    client = PuavoRestClient.new
    response = client.get("/v3/devices/#{PUAVO_ETC.hostname}/wlan_networks")

    nets = response.parse.select { |net| net['wlan_ap'] } .each do |net|
      # Magic SSID Mangling! The following Magic SSID is substituted
      # with a SSID derived from the hostname. This lets us configure
      # AP-specific networks easily via Puavo.
      next unless net['ssid'] =~ /^le8Yuek9Some5ee$/
      net['ssid'] = PUAVO_ETC.hostname.tr(' ', '')
    end

    return nets unless nets.empty?

    nets_wait = [nets_wait * 2, 3600].min
    sleep nets_wait
  end
end

def hexdigest15(str)
  md5sum = Digest::MD5.new
  md5sum << str
  md5sum.hexdigest[0..15]
end

def get_bssid(iface)
  sysdir = "/sys/class/net/#{iface}"
  phydir = "#{sysdir}/phy80211"
  devdir = "#{sysdir}/device"

  addr = File.read("#{phydir}/macaddress"  ).split(':').map { |v| v.to_i(16) }
  mask = File.read("#{phydir}/address_mask").split(':').map { |v| v.to_i(16) }

  uevent = File.read("#{devdir}/uevent")
  uevent =~ /^PRODUCT=(.+)\/(.+)\/.*$/ or uevent =~ /^PCI_ID=(.+):(.+)$/

  model_id = "%04x%04x" % [$1.to_i(16), $2.to_i(16)]

  ## For some reason, at least with some driver versions, these device
  ## models report empty address masks. However, hostapd requires that
  ## mask >= 00:00:00:00:00:03 to support at most 4 different
  ## BSSIDs. Mask 00:00:00:00:00:03 has been verified to work with
  ## devices in question.
  if ['168c0030', '168c002b', '168c0037'].include?(model_id) then
    if mask.map { |v| v == 0 } .all? then
      mask = [0x00, 0x00, 0x00, 0x00, 0x00, 0x03]
    end
  end

  addr.zip(mask).map { |(a, b)| "%02x" % (a &~ b) } .join(":")
end

def get_ht_capab(iface, channel)
  phyname = File.read("/sys/class/net/#{iface}/phy80211/name").strip

  is_ht20sgi_capab = IO.popen(['iw', phyname, 'info']) do |io|
    !io.grep(/^\s+RX HT20 SGI.*$/).empty?
  end
  $?.success? or raise 'failed to query HT capabilities'

  case channel
  when 1, 6
    is_ht20sgi_capab ? '[HT20][SHORT-GI-20]' : '[HT40+]'
  when 11
    is_ht20sgi_capab ? '[HT20][SHORT-GI-20]' : '[HT40-]'
  when 36, 44
    '[HT40+]'
  when 40, 48
    '[HT40-]'
  else
    raise "unsupported channel #{channel}"
  end
end

def run_or_fail(cmd, *args)
  system(cmd, *args)
  $?.success? or raise "command '%s' failed" % ([cmd] + args).join(' ')
end

def fill_phy_list(phy_list, band)
  iter_suitable_ifaces(band) do |iface|
    run_or_fail('ifconfig', iface, 'up')
    best_channels = scan_channels(iface, CHANNELS[band])
    free_channels = best_channels - phy_list.map { |phy| phy[:channel] }
    next if free_channels.empty?
    channel = free_channels[0]

    phy_list << {
      :iface    => iface,
      :channel  => channel,
      :bssid    => get_bssid(iface),
      :hw_mode  => CHANNELS_5G.include?(channel) ? 'a' : 'g',
      :ht_capab => get_ht_capab(iface, channel),
    }
  end
end

def get_phy_list
  phy_list = []

  fill_phy_list(phy_list, BAND_5G)
  fill_phy_list(phy_list, BAND_2G)
  fill_phy_list(phy_list, BAND_5G | BAND_2G)

  phy_list
end

def get_bss_list
  nets = get_nets_from_puavo

  # At most 4 BSSes are supported.
  nets.slice!(4..-1)

  nets.length.times.zip(nets).map do |i, net|
    {
      :index  => i,
      :bridge => hexdigest15(net['ssid']),
      :psk    => net['psk'],
      :type   => net['type'],
      :ssid   => net['ssid'],
    }
  end
end

def write_hostapd_conf(phy_list, bss_list, rundir)
  phy_list.each do |phy|
    conf = ERB.new(HOSTAPD_CONF_TEMPLATE, 3, '<>').result(binding)
    conf_filepath = File.join(rundir, "hostapd_#{phy[:iface]}.conf")
    File.write(conf_filepath, conf)
  end
end

def write_vtund_conf(bss_list, rundir)
  bss_list.each do |bss|
    conf = ERB.new(VTUND_CONF_TEMPLATE, 3, '<>').result(binding)
    conf_filepath = File.join(rundir, "vtund_#{bss[:bridge]}.conf")
    File.write(conf_filepath, conf)
  end
end

def run(kwargs = {})
  rundir       = kwargs[:rundir]       || DEFAULT_RUNDIR
  vtun_address = kwargs[:vtun_address] || DEFAULT_VTUN_ADDRESS
  vtun_port    = kwargs[:vtun_port]    || DEFAULT_VTUN_PORT

  Signal.trap('EXIT') do
    FileUtils.rm_rf(rundir)
  end

  FileUtils.mkdir_p(rundir)

  phy_list = get_phy_list
  bss_list = get_bss_list

  write_hostapd_conf(phy_list, bss_list, rundir)
  write_vtund_conf(bss_list, rundir)
end

def main
  run_kwargs = {}

  GetoptLong.new(
    ['--help', '-h', GetoptLong::NO_ARGUMENT],
    ['--rundir', GetoptLong::REQUIRED_ARGUMENT],
    ['--vtun-address', GetoptLong::REQUIRED_ARGUMENT],
    ['--vtun-port', GetoptLong::REQUIRED_ARGUMENT],
  ).each do |opt, arg|
    case opt
    when '--help'
      puts <<EOF
Usage: puavo-wlanap [OPTION]...

Tunneled WLAN accesspoint.

Options:
 -h, --help                    display this help and exit
     --rundir DIR              runtime directory, default: #{DEFAULT_RUNDIR}
     --vtun-address ADDRESS    vtun server address, default: #{DEFAULT_VTUN_ADDRESS}
     --vtun-port PORT          vtun server port, default: #{DEFAULT_VTUN_PORT}

EOF
      exit(0)
    when '--rundir'
      run_kwargs[:rundir] = arg
    when '--vtun-address'
      run_kwargs[:vtun_address] = arg
    when '--vtun-port'
      unless arg =~ /^[1-9][0-9]*$/ then
        STDERR.puts("ERROR: invalid port number (#{arg})")
        exit(1)
      end
      run_kwargs[:vtun_port] = arg.to_i
    end
  end

  if ARGV.length != 0 then
    STDERR.puts("ERROR: invalid number of arguments (#{ARGV.length}), expected 0")
    exit(1)
  end

  run(run_kwargs)
end

main
