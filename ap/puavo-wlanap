#!/bin/bash

set -eubm

on_exit()
{
    local -r exitval=$?

    ## Do not exit or terminate on error or signal anymore. We are
    ## already exiting and it would be shame to exit while exiting, yo
    ## dawg.
    set +eu
    trap '' EXIT HUP INT QUIT ABRT ALRT TERM USR1 USR2

    ## Kill our child processes. There is no reason to let Init adopt
    ## them when puavo-wlanap dies.
    pkill -TERM -P $$

    ## Burn the bridges.
    for net in "${PUAVO_WLANAP_NETS[@]}"; do
        IFS=':' read _ ssid _ <<<"${net}"
        ifconfig "${ssid}" down
        brctl delbr "${ssid}"
    done

    rm -rf "${PUAVO_WLANAP_RUNDIR}"

    exit $exitval
}

get_bssid()
{
    local -r iface=$1
    local i
    local mac
    local mask
    local bssid

    IFS=':' read -a mac <"/sys/class/net/${iface}/phy80211/macaddress"
    IFS=':' read -a mask <"/sys/class/net/${iface}/phy80211/address_mask"

    ## Prefix each element with 0x
    mac=(${mac[@]/#/0x})
    mask=(${mask[@]/#/0x})

    for (( i = 0; i <= ${#mac[@]}; ++i )); do 
        bssid[i]=$((mac[i] &~ mask[i]))
    done

    printf "%02x:" "${bssid[@]}" | head -c-1
}

## Find suitable WLAN interfaces and print their names to stdout, one
## per line.
find_ifaces()
{
    local -r hw_mode=$1
    local path
    local iface
    local driver

    for path in /sys/class/net/*; do
        iface=$(basename "${path}")

        ## We are only interested in wlan interfaces.
        grep -q '^DEVTYPE=wlan$' "${path}/uevent" || continue

        ## Find its driver.
        driver=$(sed -rn 's/^DRIVER=(.*)$/\1/p' "${path}/device/uevent")
        [ -n "${driver}" ] || {
            puavo_wlanap_log "driver not found for ${iface}, ignoring"
            continue
        }

        ## Ignore if the driver is not whitelisted.
        grep -q "${driver}" "${PUAVO_WLANAP_DATADIR}/supported_drivers" \
            || continue

        ## Ignore if it is of wrong type, i.e. the iwconfig output does
        ## not include the hw_mode char.
        iwconfig "${iface}" | sed -rn '1 s/^.*IEEE 802.11([a-z]+).*/\1/p' \
            | grep -q "${hw_mode}" || continue

        ## All tests passed, the current interface meets our
        ## requirements. Print its interface name.
        echo "${iface}"
    done
}

write_hostapd_conf()
{
    local iface
    local ssid_count
    local bssid
    local net
    local auth
    local ssid
    local psk

    ## Configure one hostapd per radio.
    for iface in "${PUAVO_WLANAP_IFACES[@]}"; do
        ssid_count=0
        bssid=$(get_bssid "${iface}")

        [ -n "${bssid}" ] || {
            puavo_wlanap_log "failed to find the first address in the block"
            return 1
        }

        ## Write interface-specific hostapd configuration to the
        ## beginning of the file.
        sed -e "s|#{PUAVO_WLANAP_IFACE}|${iface}|g" \
            -e "s|#{PUAVO_WLANAP_BSSID}|${bssid}|g" \
            -e "s|#{PUAVO_WLANAP_RUNDIR}|${PUAVO_WLANAP_RUNDIR}|g" \
            "${PUAVO_WLANAP_DATADIR}/hostapd.conf" \
            >"${PUAVO_WLANAP_RUNDIR}/${iface}_hostapd.conf"

        for net in "${PUAVO_WLANAP_NETS[@]}"; do
            IFS=':' read auth ssid psk <<<"${net}"

            ## Append network-specific hostapd configuration to the end.
            cat "${PUAVO_WLANAP_DATADIR}/${auth}_hostapd.conf" \
                >>"${PUAVO_WLANAP_RUNDIR}/${iface}_hostapd.conf"
            sed -i \
                -e "s|#{PUAVO_WLANAP_BSS}|${iface}_${ssid_count}|g" \
                -e "s|#{PUAVO_WLANAP_SSID}|${ssid}|g" \
                -e "s|#{PUAVO_WLANAP_PSK}|${psk}|g" \
                "${PUAVO_WLANAP_RUNDIR}/${iface}_hostapd.conf"
            ssid_count=$((ssid_count + 1))
        done
    done
}

write_vtund_conf()
{
    local net
    local ssid

    ## Configure one vtund client per network.
    for net in "${PUAVO_WLANAP_NETS[@]}"; do
        IFS=':' read _ ssid _ <<<"${net}"
        sed -e "s|#{PUAVO_WLANAP_LIBDIR}|${PUAVO_WLANAP_LIBDIR}|g" \
            -e "s|#{PUAVO_WLANAP_SSID}|${ssid}|g" \
            -e "s|#{PUAVO_WLANAP_RUNDIR}|${PUAVO_WLANAP_RUNDIR}|g" \
            "${PUAVO_WLANAP_DATADIR}/vtund.conf" \
            >"${PUAVO_WLANAP_RUNDIR}/${ssid}_vtund.conf"
    done
}

setup_services()
{
    write_hostapd_conf
    write_vtund_conf
}

start_services()
{
    ## Start one vtund client per network.
    for net in "${PUAVO_WLANAP_NETS[@]}"; do
        IFS=':' read _ ssid _ <<<"${net}"

        ## Setup the bridge.
        brctl addbr "${ssid}"
        brctl setfd "${ssid}" 0
        ifconfig "${ssid}" up
        dhclient -d "${ssid}" &

        vtund -n -f "${PUAVO_WLANAP_RUNDIR}/${ssid}_vtund.conf" \
            -P "${PUAVO_WLANAP_GWPORT}" \
            "${ssid}" "${PUAVO_WLANAP_GWADDR}" &
    done

    ## Magical sleep to "ensure" that bridges and tunnels are all set.
    sleep 8 & wait $!

    ## Start one hostapd per radio.
    for iface in "${PUAVO_WLANAP_IFACES[@]}"; do
        hostapd -P "${PUAVO_WLANAP_RUNDIR}/${iface}_hostapd.pid" \
            "${PUAVO_WLANAP_RUNDIR}/${iface}_hostapd.conf" &
    done
}

parse_args()
{
    PUAVO_WLANAP_ARGS_DAEMON=0

    if [ $# -eq 1 ]; then
        if [ "$1" = "--daemon" ]; then
            PUAVO_WLANAP_ARGS_DAEMON=1
            return 0
        fi
        puavo_wlanap_log "unexpected argument '$1'"
        echo "Usage: $(basename $0) [--daemon]" >&2
        return 1
    elif [ $# -gt 2 ]; then
        puavo_wlanap_log "too many arguments"
        echo "Usage: $(basename $0) [--daemon]" >&2
        return 1
    fi
}

report_status()
{
    local -r output=$(hostapd_cli -p "${PUAVO_WLANAP_RUNDIR}/hostapd" all_sta)
    local -r devices=$(echo -n "${output}" | sed -n 's/^dot11RSNAStatsSTAAddress=//p' | tr '\n' ',')

    puavo_wlanap_report <<EOF
wlan_event:hotspot_state
connected_devices:[${devices}]
EOF
}

read_config()
{
    . "${PUAVO_WLANAP_DATADIR}/config"

    ## The user might have deleted the configuration file, that's ok.
    [ -r "${PUAVO_WLANAP_CONFDIR}/config" ] && . "${PUAVO_WLANAP_CONFDIR}/config"

    readarray -n0 -t PUAVO_WLANAP_NETS </etc/puavo/wlan/ssid
    if [ ${#PUAVO_WLANAP_NETS[@]} -eq 0 ]; then
        puavo_wlanap_log "no networks defined"
        return 1
    fi

    for net in "${PUAVO_WLANAP_NETS[@]}"; do
        IFS=':' read auth ssid psk <<<"${net}"
        case "${auth}" in
            open)
                if [ -n "${psk}" ]; then
                    puavo_wlanap_log "auth type is 'open', but psk was defined"
                fi
                ;;
            psk)
                if [ "${#psk}" -lt 8 -o "${#psk}" -gt 63 ]; then
                    puavo_wlanap_log "psk must be 8-63 characters long"
                    return 1
                fi
                ;;
            *)
                puavo_wlanap_log "unknown auth type '${auth}'"
                return 1
                ;;
        esac
    done
}

## We don't know yet where our data, libs and configs have been
## installed, but we do know that the following script knows it and we do
## know where the following script is (its in PATH!).
. puavo-wlanap-env

## Import library routines.
. "${PUAVO_WLANAP_LIBDIR}/common.sh"

read_config

parse_args "$@"

if [ "${PUAVO_WLANAP_ARGS_DAEMON}" -ne 0 ]; then
    daemon --noconfig --stderr='daemon.info' --name='puavo-wlanap' -- puavo-wlanap
    exit 0
fi

## After this point the process is getting hot and starts taking actions
## which might have persistent side-effects (files, directories,
## bridges, other processes, etc.). The trap is set to ensure that
## everything gets cleaned up properly afterwards.
trap on_exit EXIT

mkdir -p "${PUAVO_WLANAP_RUNDIR}"

setup_services

start_services

## Serve forever.
while true; do
    sleep 3 & wait $!

    ## Keep going even if reporting fails.
    report_status || true
done
