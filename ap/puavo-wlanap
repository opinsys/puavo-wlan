#!/usr/bin/env ruby1.9.1
# coding: utf-8

# = Puavo's Tunneled WLAN Access Point
#
# Author    :: Tuomas Räsänen <tuomasjjrasanen@tjjr.fi>
# Copyright :: Copyright (C) 2015 Opinsys Oy
# License   :: GPLv2+
#
# == Usage
#
# Get help:
#   puavo-wlanap --help

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 USA.

# Standard library modules.
require 'digest'
require 'erb'
require 'fileutils'
require 'getoptlong'
require 'pathname'
require 'socket'
require 'timeout'

require 'puavo/etc'
require 'puavo/rest-client'

module Log

  def self.info(msg)
    Log.log(:INFO, msg)
  end

  def self.log(priority, msg)
    STDERR.puts("#{Time.now.utc} puavo-wlanap[#{Process.pid}]: " \
                "#{priority}: #{msg}")
  end

  def self.warning(msg)
    Log.log(:WARNING, msg)
  end

  def self.error(msg)
    Log.log(:ERROR, msg)
  end

end

module Dot11

  ## For some reason, at least with some driver versions, these device
  ## models report empty address masks. However, hostapd requires that
  ## mask >= 00:00:00:00:00:03 to support at most 4 different
  ## BSSIDs. Mask 00:00:00:00:00:03 has been verified to work with
  ## devices in question.
  MASK_QUIRK_MODEL_IDS = [
                          '168c0029',
                          '168c0030',
                          '168c002b',
                          '168c002e',
                          '168c0037',
                         ]

  # Chips handled by following drivers seem to have pretty good chances
  # to work properly.
  SUPPORTED_DRIVERS = ['ath9k', 'rt2800pci', 'rt2800usb']

  BAND_2G = 1
  BAND_5G = 2

  CHANNELS_2G = [ 1,  6, 11]
  CHANNELS_5G = [36, 40, 44, 48]

  CHANNELS = {
    BAND_2G           => CHANNELS_2G,
    BAND_5G           => CHANNELS_5G,
    BAND_2G | BAND_5G => CHANNELS_2G + CHANNELS_5G,
  }

  class Phy

    def initialize(name)
      @name = name
      path = File.join('/sys/class/ieee80211', @name)
      @index = File.read(File.join(path), 'index').to_i
    end

    def add_vif(name)
      run_or_fail('iw', 'phy', @name, 'interface', 'add', name, 'type', 'managed')
      Vif.new(name)
    end

    def each_vif
      retval    = nil
      phy_found = false

      IO.popen(['iw', 'dev']) do |io|
        io.each_line do |line|

          is_phy_line = line =~ /^phy#(\d+)$/
          unless phy_found
            phy_found = $1.to_i == @index
            next
          end

          # Encountering another phy line ends the current phy section.
          break if is_phy_line

          # Ignore all but interface lines.
          if line =~ /^\s+Interface (.*)$/
            retval = yield Vif.new($1)
          end

        end
      end

      fail 'failed to list interfaces' unless $?.success?
      retval
    end

    def band
      band = 0

      IO.popen(['iw', 'phy', @name, 'info']) do |io|
        until io.eof? do
          next unless io.gets =~ /^\s+Frequencies:$/

          io.gets =~ /^\s+\* (\d+) MHz .*$/
          case $1
          when '2412'
            band |= Dot1::BAND_2G
          when '5180'
            band |= Dot1::BAND_5G
          else
            Log.warning("phy {@name} has an unsupported band")
          end
        end
      end
      fail 'failed to query supported bands' unless $?.success?

      band
    end

    def driver
      uevent_path = File.join('/sys/class/ieee80211',
                              @name, 'device', 'uevent')
      File.open(uevent_path) do |file|
        file.each_line do |line|
          next unless /^DRIVER=(.*)$/ =~ line
          return $1
        end
      end
      nil
    end

    def has_supported_driver?
      Dot11::SUPPORTED_DRIVERS.include?(self.driver)
    end

    def ht_capab(channel)
      is_ht20sgi_capab = IO.popen(['iw', @name, 'info']) do |io|
        !io.grep(/^\s+RX HT20 SGI.*$/).empty?
      end
      $?.success? or fail 'failed to query HT20 SGI capability'

      is_ht40sgi_capab = IO.popen(['iw', @name, 'info']) do |io|
        !io.grep(/^\s+RX HT40 SGI.*$/).empty?
      end
      $?.success? or fail 'failed to query HT40 SGI capability'

      case channel
      when 1, 6, 11
        '[HT20]'
      when 36, 44
        '[HT40+]' + (is_ht40sgi_capab ? '[SHORT-GI-40]' : '')
      when 40, 48
        '[HT40-]' + (is_ht40sgi_capab ? '[SHORT-GI-40]' : '')
      else
        fail "unsupported channel #{channel}"
      end + (is_ht20sgi_capab ? '[SHORT-GI-20]' : '')

    end

  end

  class Vif

    attr_reader :name

    def initialize(name)
      @name = name
    end

    def scan(band)
      # Prime results with worst possible signal levels.
      results = {}
      Dot11::CHANNELS[band].each { |ch| results[ch] = -999 }

      IO.popen(['iwlist', @name, 'scan']) do |io|
        io.each_line do |line|
          next unless line =~ /^\s+Cell [0-9]+ - Address: .*$/

          io.readline.strip =~ /^Channel:([0-9]+)$/
          channel = $1.to_i

          io.readline.strip # Ignore frequency line.

          io.readline.strip =~ /^Quality=[0-9]+\/[0-9]+\s+Signal level=(-[0-9]+) dBm.*$/
          signal_level = $1.to_i

          if results.has_key?(channel)
            results[channel] = signal_level if results[channel] < signal_level
          end
        end
      end
      $?.success? or fail "failed to scan with interface #{@name}"

      # Return channels in ascending signal level order.
      Hash[results.sort_by { |channel, signal_level| signal_level }].keys
    end

  end

  def self.each_phy
    Dir.glob('/sys/class/ieee80211/*') do |phy_path|
      phy_name = File.basename(phy_path)
      yield Phy.new(phy_name)
    end
  end

  def self.get_interface_driver(iface)
    File.open(File.join('/sys/class/net', iface, 'device', 'uevent')) do |file|
      file.each_line do |line|
        next unless /^DRIVER=(.*)$/ =~ line
        return $1
      end
    end
    nil
  end

  def self.has_supported_driver(iface)
    driver = Dot11.get_interface_driver(iface)
    Dot11::SUPPORTED_DRIVERS.include?(driver)
  end

  def self.is_wlan_interface(iface)
    File.open(File.join('/sys/class/net', iface, 'uevent')) do |file|
      file.each_line do |line|
        return true if /^DEVTYPE=wlan$/ =~ line
      end
    end
    false
  end

  def self.each_interface
    Dir.glob('/sys/class/net/*') do |path|
      iface = File.basename(path)
      next unless Dot11.is_wlan_interface(iface)
      next unless Dot11.has_supported_driver(iface)
      yield iface
    end
  end

  def self.fill_phy_list(phy_list, band)
    Dot11.each_interface do |iface|
      next unless band == Dot11.get_band(iface)
      run_or_fail('ifconfig', iface, 'up')
      best_channels = Dot11.scan(iface, band)
      free_channels = best_channels - phy_list.map { |phy| phy[:channel] }
      next if free_channels.empty?
      channel = free_channels[0]

      phy_list << {
        :iface    => iface,
        :channel  => channel,
        :bssid    => Dot11.get_bssid(iface),
        :hw_mode  => Dot11::CHANNELS_5G.include?(channel) ? 'a' : 'g',
        :ht_capab => Dot11.get_ht_capab(iface, channel),
      }
    end
  end

  def self.find_phys
    phy_list = []

    Dot11.fill_phy_list(phy_list, Dot11::BAND_5G)
    Dot11.fill_phy_list(phy_list, Dot11::BAND_2G)
    Dot11.fill_phy_list(phy_list, Dot11::BAND_5G | Dot11::BAND_2G)

    phy_list
  end

  def self.get_band(iface)
    hw_mode = IO.popen(['iwconfig', iface]) do |io|
      io.gets =~ /^.* IEEE 802.11([a-z]+).*$/
      break $1
    end
    fail 'failed to query supported bands' unless $?.success?

    band = 0
    band |= Dot11::BAND_5G if hw_mode.include?('a')
    band |= Dot11::BAND_2G if hw_mode.include?('g')

    band
  end

  def self.get_bssid(iface)
    sysdir = "/sys/class/net/#{iface}"
    phydir = "#{sysdir}/phy80211"
    devdir = "#{sysdir}/device"

    addr = File.read("#{phydir}/macaddress"  ).split(':').map { |v| v.to_i(16) }
    mask = File.read("#{phydir}/address_mask").split(':').map { |v| v.to_i(16) }

    uevent = File.read("#{devdir}/uevent")
    uevent =~ /^PRODUCT=(.+)\/(.+)\/.*$/ or uevent =~ /^PCI_ID=(.+):(.+)$/

    model_id = "%04x%04x" % [$1.to_i(16), $2.to_i(16)]

    if Dot11::MASK_QUIRK_MODEL_IDS.include?(model_id)
      if mask.map { |v| v == 0 } .all?
        mask = [0x00, 0x00, 0x00, 0x00, 0x00, 0x03]
      end
    end

    addr.zip(mask).map { |(a, b)| "%02x" % (a &~ b) } .join(":")
  end

  def self.get_ht_capab(iface, channel)
    phyname = File.read("/sys/class/net/#{iface}/phy80211/name").strip

    is_ht20sgi_capab = IO.popen(['iw', phyname, 'info']) do |io|
      !io.grep(/^\s+RX HT20 SGI.*$/).empty?
    end
    $?.success? or fail 'failed to query HT20 SGI capability'

    is_ht40sgi_capab = IO.popen(['iw', phyname, 'info']) do |io|
      !io.grep(/^\s+RX HT40 SGI.*$/).empty?
    end
    $?.success? or fail 'failed to query HT40 SGI capability'

    case channel
    when 1, 6, 11
      '[HT20]'
    when 36, 44
      '[HT40+]' + (is_ht40sgi_capab ? '[SHORT-GI-40]' : '')
    when 40, 48
      '[HT40-]' + (is_ht40sgi_capab ? '[SHORT-GI-40]' : '')
    else
      fail "unsupported channel #{channel}"
    end + (is_ht20sgi_capab ? '[SHORT-GI-20]' : '')
  end

  def self.scan(iface, band)
    # Prime results with worst possible signal levels.
    results = {}
    Dot11::CHANNELS[band].each { |ch| results[ch] = -999 }

    IO.popen(['iwlist', iface, 'scan']) do |io|
      io.each_line do |line|
        next unless line =~ /^\s+Cell [0-9]+ - Address: .*$/

        io.readline.strip =~ /^Channel:([0-9]+)$/
        channel = $1.to_i

        io.readline.strip # Ignore frequency line.

        io.readline.strip =~ /^Quality=[0-9]+\/[0-9]+\s+Signal level=(-[0-9]+) dBm.*$/
        signal_level = $1.to_i

        if results.has_key?(channel)
          results[channel] = signal_level if results[channel] < signal_level
        end
      end
    end
    $?.success? or fail "failed to scan with interface #{iface}"

    # Return channels in ascending signal level order.
    Hash[results.sort_by { |channel, signal_level| signal_level }].keys
  end

end

module PuavoAPI

  def self.get_nets
    nets_wait = 1
    while true
      client = PuavoRestClient.new
      response = client.get("/v3/devices/#{PUAVO_ETC.hostname}/wlan_networks")

      nets = response.parse.select { |net| net['wlan_ap'] } .each do |net|
        # Magic SSID Mangling! The following Magic SSID is substituted
        # with a SSID derived from the hostname. This lets us configure
        # AP-specific networks easily via Puavo.
        next unless net['ssid'] =~ /^le8Yuek9Some5ee$/
        net['ssid'] = PUAVO_ETC.hostname.tr(' ', '')
      end

      return nets unless nets.empty?

      nets_wait = [nets_wait * 2, 3600].min
      sleep nets_wait
    end
  end

  def self.get_conf
    client = PuavoRestClient.new
    response = client.get("/v3/devices/#{PUAVO_ETC.hostname}")

    conf = {}
    response.parse['tags'].each do |tag|
      if /^txpower:([0-9]+)$/ =~ tag
        txpower = $1.to_i
        ## Multiple tags starting with txpower: might be given, let's
        ## take the most restrictive.
        conf[:txpower] = [conf.fetch(:txpower, txpower), txpower].min
      elsif /^txpower5:([0-9]+)$/ =~ tag
        txpower5 = $1.to_i
        ## Multiple tags starting with txpower5: might be given, let's
        ## take the most restrictive.
        conf[:txpower5] = [conf.fetch(:txpower5, txpower5), txpower5].min
      end
    end

    conf
  end

end

RUNDIR                     = '/run/puavo-wlanap'
CTRLSOCKET                 = File.join(RUNDIR, 'ctrlsocket')
THIS_SCRIPT                = Pathname.new($0).realpath
HOSTAPD_ACTION_SCRIPT      = THIS_SCRIPT.dirname.join('puavo-wlanap-hostapd-action')
HOSTAPD_CTRL_INTERFACE_DIR = File.join(RUNDIR, 'hostapd')

HOSTAPD_CONF_TEMPLATE = <<'EOF'
## PHY-specific options ##
interface=<%= phy[:iface] %>
bssid=<%= phy[:bssid] %>
driver=nl80211
country_code=FI
hw_mode=<%= phy[:hw_mode] %>
channel=<%= phy[:channel] %>
max_num_sta=1000
wmm_enabled=1
ctrl_interface=<%= HOSTAPD_CTRL_INTERFACE_DIR %>
ieee80211n=1
ht_capab=<%= phy[:ht_capab] %>
wds_sta=1
<% for bss in @bss_list %>

## BSS-specific options ##
<% if bss[:index] > 0 %>
bss=<%= phy[:iface] %>_<%= bss[:index] %>
<% end %>
ssid=<%= bss[:ssid] %>
bridge=<%= bss[:bridge] %>
<% if bss[:type] == 'open' %>
wpa=0
<% else %>
wpa=2
auth_algs=3
wpa_passphrase=<%= bss[:password] %>
rsn_pairwise=CCMP
wpa_key_mgmt=WPA-PSK
eapol_version=1
eapol_key_index_workaround=1
eap_reauth_period=0
wpa_strict_rekey=0
wpa_group_rekey=0
wpa_gmk_rekey=0
<% end %>
<% end %>
EOF

VTUND_CONF_TEMPLATE = <<'EOF'
options {
    syslog daemon;
}

puavo-wlanap {
    passwd    wlan;
    type      ether;
    proto     udp;
    speed     0;     # Full speed ahead! Aye aye, captain!
    encrypt   no;
    compress  no;
    multi     yes;

    up {
        program "<%= THIS_SCRIPT %> --ctrlmsg 'vtun-up:%%:<%= bss[:bridge] %>'";
    };
}
EOF

def hexdigest15(str)
  md5sum = Digest::MD5.new
  md5sum << str
  md5sum.hexdigest[0..14]
end

def run_or_fail(cmd, *args)
  cmd_string = ([cmd] + args).join(' ')
  system(cmd, *args)
  $?.success? or fail "command '#{cmd_string}' failed"
end

class AccessPoint

  VTUN_ADDRESS = 'wlangw'
  VTUN_PORT    = 45045

  def initialize(kwargs = {})
    @bss_list      = []
    @ctrlconn      = nil
    @ctrlconn_time = nil
    @ctrlserv      = nil
    @phy_list      = []
    @services      = {}
    @vtun_address  = kwargs.fetch(:vtun_address, VTUN_ADDRESS)
    @vtun_port     = kwargs.fetch(:vtun_port, VTUN_PORT)
  end

  def run
    Log.info('starting')
    FileUtils.mkdir_p(RUNDIR)
    File.open(File.join(RUNDIR, 'lock'), File::RDWR | File::CREAT, 0640) do |lockfile|
      unless lockfile.flock(File::LOCK_EX | File::LOCK_NB)
        Log.error("another instance of puavo-wlanap is already running in #{RUNDIR}")
        return 1
      end
      run_locked
    end
  end

  private

  def run_locked
    @phy_list = Dot11.find_phys
    if @phy_list.empty?
      Log.error('no suitable physical interfaces available')
      return 1
    end

    conf = PuavoAPI.get_conf
    nets = PuavoAPI.get_nets

    @phy_list.each do |phy|
      phy[:txpower] = conf[:txpower]
      if Dot11::CHANNELS_5G.include? phy[:channel]
        phy[:txpower] = conf.fetch(:txpower5, phy[:txpower])
      end
    end

    if nets.empty?
      Log.error('no networks defined')
      return 1
    end

    # At most 4 BSSes are supported.
    ignored_nets = nets.slice!(4..-1)
    if !ignored_nets.nil? && !ignored_nets.empty?
      Log.warning("more than 4 networks defined, ignoring " +
                  ignored_nets.map{ |n| n['ssid'] }.join(', '))
    end

    nets.length.times.zip(nets).map do |i, net|
      @bss_list << {
        :index    => i,
        :bridge   => hexdigest15(net['ssid']),
        :password => net['password'],
        :type     => net['type'],
        :ssid     => net['ssid'],
      }
    end

    Signal.trap('EXIT') do
      Log.info('exiting')
      Process.kill('-SIGTERM', 0)

      @bss_list.each do |bss|
        # Ignore errors, we are already exiting.
        system('ifconfig', bss[:bridge], 'down')
        system('brctl', 'delbr', bss[:bridge])
      end

      FileUtils.rm_rf(RUNDIR)
      Log.info('bye')
    end

    write_hostapd_confs
    write_vtund_confs

    [:HUP, :USR1, :USR2].each { |s| Signal.trap(s, 'SIG_IGN') }

    sigqueue = []
    selfpipe_r, selfpipe_w = IO.pipe

    [:CHLD, :INT, :QUIT, :TERM].each do |signal|
      Signal.trap(signal) do
        sigqueue << signal
        selfpipe_w.write_nonblock('o')
      end
    end

    @ctrlserv = UNIXServer.new(CTRLSOCKET)

    start_vtunds
    start_hostapds

    Log.info('started')
    loop do
      signal = sigqueue.pop
      case signal

      when :INT, :QUIT, :TERM
        Log.error("received fatal signal #{signal}")
        return 1

      when :CHLD
        child_pid = Process.wait(0, Process::WNOHANG)
        if @services.has_key?(child_pid)
          child_name = @services[child_pid]
          Log.error("child service #{child_name} died")
          return 1
        end

      else
        reads   = [selfpipe_r, @ctrlconn.nil? ? @ctrlserv : @ctrlconn]
        timeout = @ctrlconn.nil? ? nil : [0, 5 - (Time.now - @ctrlconn_time)].max

        ready = IO.select(reads, [], [], timeout)

        if ready.nil?
          if @ctrlconn && Time.now - @ctrlconn_time > 5
            Log.warning('control socket connection timeout')
            close_ctrlconn
          end
          next
        end

        selfpipe_r.read_nonblock(1) if ready[0].include?(selfpipe_r)
        accept_ctrlconn             if ready[0].include?(@ctrlserv)
        handle_ctrlconn             if ready[0].include?(@ctrlconn)

      end
    end
  end

  def accept_ctrlconn
    @ctrlconn      = @ctrlserv.accept
    @ctrlconn_time = Time.now
  end

  def close_ctrlconn
    @ctrlconn.close

    @ctrlconn      = nil
    @ctrlconn_time = nil
  end

  def handle_ctrlconn
    if @ctrlconn.eof?
      Log.warning('received invalid control message')
    else
      handle_ctrlmsg(@ctrlconn.readline)
    end
  ensure
    close_ctrlconn
  end

  def handle_ctrlmsg(line)
    line.strip!
    cmd, sep, args = line.partition(':')
    case cmd
    when 'hostapd-event'
      handle_ctrlmsg_hostapd_event(args)
    when 'vtun-up'
      handle_ctrlmsg_vtun_up(args)
    else
      Log.warning("received unknown control message: #{line}")
    end
  end

  def handle_ctrlmsg_hostapd_event(args)
    iface, sep, tail = args.partition(':')
    if sep.empty?
      Log.warning("received invalid hostapd-event: #{args}")
      return false
    end

    event, sep, tail = tail.partition(':')
    if sep.empty?
      Log.warning("received invalid hostapd-event: #{args}")
      return false
    end

    case event

    when 'AP-STA-CONNECTED'
      mac = tail

    when 'AP-STA-DISCONNECTED'
      mac = tail

    else
      Log.warning("received unhandled hostapd-event: #{args}")
      return false

    end

    true
  end

  def handle_ctrlmsg_vtun_up(args)
    iface, *bridge = args.split(':')
    if bridge.length == 1
      bridge = bridge[0]
      run_or_fail('ifconfig', iface, 'up')
      run_or_fail('brctl', 'addif', bridge, iface)
      dhclient_pid = spawn('dhclient', '-d', bridge)
      @services[dhclient_pid] = "dhclient_#{bridge}"
    else
      Log.warning("received invalid vtun-up arguments #{args}")
    end
  end

  def start_vtunds
    @bss_list.each do |bss|
      run_or_fail('brctl', 'addbr', bss[:bridge])
      run_or_fail('brctl', 'setfd', bss[:bridge], '0')
      run_or_fail('ifconfig', bss[:bridge], 'up')
      vtund_name = "vtund_#{bss[:bridge]}"
      vtund_conffile = File.join(RUNDIR, "#{vtund_name}.conf")
      vtund_pid = spawn('vtund', '-n', '-P', @vtun_port.to_s,
                        '-f', vtund_conffile,
                        'puavo-wlanap', @vtun_address)
      @services[vtund_pid] = vtund_name
      Log.info("spawned #{vtund_name}")
    end
  end

  def start_hostapds
    @phy_list.each do |phy|
      unless phy[:txpower].nil?
        system('iwconfig', phy[:iface], 'txpower', phy[:txpower].to_s)
      end

      hostapd_name = "hostapd_#{phy[:iface]}"
      hostapd_pidfile = File.join(RUNDIR, "#{hostapd_name}.pid")
      hostapd_conffile = File.join(RUNDIR, "#{hostapd_name}.conf")
      hostapd_pid = spawn('hostapd', '-P', hostapd_pidfile, hostapd_conffile)
      @services[hostapd_pid] = hostapd_name
      Log.info("spawned #{hostapd_name}")

      Timeout.timeout(5) do
        loop do
          break if File.exists?("#{HOSTAPD_CTRL_INTERFACE_DIR}/#{phy[:iface]}")
          Log.info("waiting for hostapd control socket " \
                   "#{HOSTAPD_CTRL_INTERFACE_DIR}/#{phy[:iface]}")
          sleep 0.5
        end
      end
      Log.info("found hostapd control socket " \
               "#{HOSTAPD_CTRL_INTERFACE_DIR}/#{phy[:iface]}")

      hostapd_cli_pid = spawn('hostapd_cli',
                              "-i#{phy[:iface]}",
                              "-p#{HOSTAPD_CTRL_INTERFACE_DIR}",
                              "-a#{HOSTAPD_ACTION_SCRIPT}")
      @services[hostapd_cli_pid] = "hostapd_cli_#{phy[:iface]}"
    end
  end

  def write_conf(filename, conf)
    File.open(File.join(RUNDIR, filename), 'w', 0640) do |file|
      file.write(conf)
    end
  end

  def write_hostapd_confs
    @phy_list.each do |phy|
      @bss_list.each do |bss|
        conf = ERB.new(HOSTAPD_CONF_TEMPLATE, 3, '<>').result(binding)
        write_conf("hostapd_#{phy[:iface]}.conf", conf)
      end
    end
  end

  def write_vtund_confs
    @bss_list.each do |bss|
      conf = ERB.new(VTUND_CONF_TEMPLATE, 3, '<>').result(binding)
      write_conf("vtund_#{bss[:bridge]}.conf", conf)
    end
  end

end

def main
  opts    = {}
  ctrlmsg = nil

  GetoptLong.new(
    ['--ctrlmsg'                   , GetoptLong::REQUIRED_ARGUMENT],
    ['--help', '-h'                , GetoptLong::NO_ARGUMENT],
    ['--vtun-address'              , GetoptLong::REQUIRED_ARGUMENT],
    ['--vtun-port'                 , GetoptLong::REQUIRED_ARGUMENT],
  ).each do |opt, arg|
    case opt
    when '--ctrlmsg'
      unless ctrlmsg.nil?
        Log.error('--ctrlmsg can be given only once')
        return 1
      end
      ctrlmsg = arg

    when '--help'
      puts <<EOF
Usage: puavo-wlanap [OPTION]...

Puavo's Tunneled WLAN Access Point.

Options:
 -h, --help
         Display this help and exit.

     --vtun-address ADDRESS
         Set the address of the vtun server, default: #{AccessPoint::VTUN_ADDRESS}

     --vtun-port PORT
         Set the port of the vtun server, default: #{AccessPoint::VTUN_PORT}

EOF
      return 0

    when '--vtun-address'
      if opts.has_key? :vtun_address
        Log.error('--vtun-address can be given only once')
        return 1
      end
      opts[:vtun_address] = arg

    when '--vtun-port'
      if opts.has_key? :vtun_port
        Log.error('--vtun-port can be given only once')
        return 1
      end
      unless arg =~ /^[1-9][0-9]*$/
        Log.error("invalid port number (#{arg})")
        return 1
      end
      opts[:vtun_port] = arg.to_i

    end
  end

  if ARGV.length != 0
    Log.error("invalid number of arguments (#{ARGV.length}), expected 0")
    return 1
  end

  unless ctrlmsg.nil?
    UNIXSocket.open(CTRLSOCKET) do |ctrlsocket|
      ctrlsocket.puts(ctrlmsg)
    end
    return 0
  end

  AccessPoint.new(opts).run
end

exit(main())
