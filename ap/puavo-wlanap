#!/usr/bin/env ruby1.9.1
# coding: utf-8

# = Puavo's Tunneled WLAN Accesspoint
#
# Author    :: Tuomas Räsänen <tuomasjjrasanen@tjjr.fi>
# Copyright :: Copyright (C) 2015 Opinsys Oy
# License   :: GPLv2+
#
# == Usage
#
# Get help:
#   puavo-wlanap --help

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 USA.

# Standard library modules.
require 'digest'
require 'fileutils'
require 'getoptlong'

# Third-party modules.
require 'puavo/etc'
require 'puavo/rest-client'

# Default runtime directory, use +--rundir+ to override.
DEFAULT_RUNDIR       = '/run/puavo-wlanap'

# Default vtun server address to connect to, use +--vtun-address+ to
# override.
DEFAULT_VTUN_ADDRESS = 'wlangw'

# Default vtun server port to connect to, use +--vtun-port+ to
# override.
DEFAULT_VTUN_PORT    = 45045

BAND_2G = 1
BAND_5G = 2

CHANNELS_2G = [ 1,  6, 11]
CHANNELS_5G = [36, 40, 44, 48]

CHANNELS = {
  BAND_2G           => CHANNELS_2G,
  BAND_5G           => CHANNELS_5G,
  BAND_2G | BAND_5G => CHANNELS_2G + CHANNELS_5G,
}

# Return the name of the interface driver.
def get_iface_driver(iface)
  File.open(File.join('/sys/class/net', iface, 'device', 'uevent')) do |file|
    file.each_line do |line|
      next unless /^DRIVER=(.*)$/ =~ line
      return $1
    end
  end
  nil
end

def has_supported_driver(iface)
  driver = get_iface_driver(iface)
  ['ath9k', 'rt2800pci', 'rt2800usb'].include?(driver)
end

# Return boolean indicating whether the interface is a WLAN interface.
def is_wlan_iface(iface)
  File.open(File.join('/sys/class/net', iface, 'uevent')) do |file|
    file.each_line do |line|
      return true if /^DEVTYPE=wlan$/ =~ line
    end
  end
  false
end

def get_band(iface)
  hw_mode = IO.popen(['iwconfig', iface]) do |io|
    io.gets =~ /^.* IEEE 802.11([a-z]+).*$/
    break $1
  end
  raise 'failed to query supported bands' unless $?.success?

  band = 0
  band |= BAND_5G if hw_mode.include?('a')
  band |= BAND_2G if hw_mode.include?('g')

  band
end

# Yield names of interfaces matching the given hardware mode.
def iter_suitable_ifaces(band)
  Dir.glob('/sys/class/net/*') do |path|
    iface = File.basename(path)
    next unless is_wlan_iface(iface)
    next unless has_supported_driver(iface)
    next unless band == get_band(iface)
    yield iface
  end
end

def scan(iface)
  IO.popen(['iwlist', iface, 'scan']) do |io|
    io.each_line do |line|
      next unless line =~ /^\s+Cell [0-9]+ - Address: .*$/

      io.readline.strip =~ /^Channel:([0-9]+)$/
      channel = $1.to_i

      io.readline.strip # Ignore frequency line.

      io.readline.strip =~ /^Quality=[0-9]+\/[0-9]+\s+Signal level=(-[0-9]+) dBm.*$/
      signal_level = $1.to_i

      yield channel, signal_level
    end
  end
  $?.success? or raise "failed to scan with interface #{iface}"
end

def scan_channels(iface, channels)
  # Prime results with worst possible signal levels.
  results = {}
  channels.each { |ch| results[ch] = -999 }

  # Update results with scan results.
  scan iface do |ch, siglvl|
    next unless results.has_key?(ch)
    results[ch] = siglvl if results[ch] < siglvl
  end

  # Return channels in ascending signal level order.
  Hash[results.sort_by { |ch, siglvl| siglvl }].keys
end

def get_nets_from_puavo
  nets_wait = 1
  while true
    client = PuavoRestClient.new
    response = client.get("/v3/devices/#{PUAVO_ETC.hostname}/wlan_networks")

    nets = response.parse.select { |net| net['wlan_ap'] } .each do |net|
      # Magic SSID Mangling! The following Magic SSID is substituted
      # with a SSID derived from the hostname. This lets us configure
      # AP-specific networks easily via Puavo.
      next unless net['ssid'] =~ /^le8Yuek9Some5ee$/
      net['ssid'] = PUAVO_ETC.hostname.tr(' ', '')
    end

    return nets unless nets.empty?

    nets_wait = [nets_wait * 2, 3600].min
    sleep nets_wait
  end
end

def hexdigest15(str)
  md5sum = Digest::MD5.new
  md5sum << str
  md5sum.hexdigest[0..15]
end

def get_bssid(iface)
  sysdir = "/sys/class/net/#{iface}"
  phydir = "#{sysdir}/phy80211"
  devdir = "#{sysdir}/device"

  addr = File.read("#{phydir}/macaddress"  ).split(':').map { |v| v.to_i(16) }
  mask = File.read("#{phydir}/address_mask").split(':').map { |v| v.to_i(16) }

  uevent = File.read("#{devdir}/uevent")
  uevent =~ /^PRODUCT=(.+)\/(.+)\/.*$/ or uevent =~ /^PCI_ID=(.+):(.+)$/

  model_id = "%04x%04x" % [$1.to_i(16), $2.to_i(16)]

  ## For some reason, at least with some driver versions, these device
  ## models report empty address masks. However, hostapd requires that
  ## mask >= 00:00:00:00:00:03 to support at most 4 different
  ## BSSIDs. Mask 00:00:00:00:00:03 has been verified to work with
  ## devices in question.
  if ['168c0030', '168c002b', '168c0037'].include?(model_id) then
    if mask.map { |v| v == 0 } .all? then
      mask = [0x00, 0x00, 0x00, 0x00, 0x00, 0x03]
    end
  end

  addr.zip(mask).map { |(a, b)| "%02x" % (a &~ b) } .join(":")
end

def get_ht_capab(iface, channel)
  phyname = File.read("/sys/class/net/#{iface}/phy80211/name").strip

  is_ht20sgi_capab = IO.popen(['iw', phyname, 'info']) do |io|
    !io.grep(/^\s+RX HT20 SGI.*$/).empty?
  end
  $?.success? or raise 'failed to query HT capabilities'

  case channel
  when 1, 6
    is_ht20sgi_capab ? '[HT20][SHORT-GI-20]' : '[HT40+]'
  when 11
    is_ht20sgi_capab ? '[HT20][SHORT-GI-20]' : '[HT40-]'
  when 36, 44
    '[HT40+]'
  when 40, 48
    '[HT40-]'
  else
    raise "unsupported channel #{channel}"
  end
end

# Bring interface up and return true on sucess and false otherwise.
def ifup(iface)
  system('ifconfig', iface, 'up')
  $?.success? or raise "failed to bring interface #{iface} up"
end

def fill_phy_conf(phy_conf, band)
  iter_suitable_ifaces(band) do |iface|
    raise "interface #{iface} is already configured" if phy_conf.has_key?(iface)
    ifup(iface)
    best_channels = scan_channels(iface, CHANNELS[band])
    free_channels = best_channels - phy_conf.values
    next if free_channels.empty?
    phy_conf[iface] = {:channel => free_channels[0]}
  end
end

def get_phy_conf
  phy_conf = {}

  fill_phy_conf(phy_conf, BAND_5G)
  fill_phy_conf(phy_conf, BAND_2G)
  fill_phy_conf(phy_conf, BAND_5G | BAND_2G)

  phy_conf
end

def get_bss_conf
  nets = get_nets_from_puavo

  # At most 4 BSSes are supported.
  nets.slice!(4..-1)
end

def run(kwargs = {})
  rundir       = kwargs[:rundir]       || DEFAULT_RUNDIR
  vtun_address = kwargs[:vtun_address] || DEFAULT_VTUN_ADDRESS
  vtun_port    = kwargs[:vtun_port]    || DEFAULT_VTUN_PORT

  Signal.trap('EXIT') do
    FileUtils.rm_rf(rundir)
  end

  FileUtils.mkdir_p(rundir)

  phy_conf = get_phy_conf
  bss_conf = get_bss_conf
end

def main
  run_kwargs = {}

  GetoptLong.new(
    ['--help', '-h', GetoptLong::NO_ARGUMENT],
    ['--rundir', GetoptLong::REQUIRED_ARGUMENT],
    ['--vtun-address', GetoptLong::REQUIRED_ARGUMENT],
    ['--vtun-port', GetoptLong::REQUIRED_ARGUMENT],
  ).each do |opt, arg|
    case opt
    when '--help'
      puts <<EOF
Usage: puavo-wlanap [OPTION]...

Tunneled WLAN accesspoint.

Options:
 -h, --help                    display this help and exit
     --rundir DIR              runtime directory, default: #{DEFAULT_RUNDIR}
     --vtun-address ADDRESS    vtun server address, default: #{DEFAULT_VTUN_ADDRESS}
     --vtun-port PORT          vtun server port, default: #{DEFAULT_VTUN_PORT}

EOF
      exit(0)
    when '--rundir'
      run_kwargs[:rundir] = arg
    when '--vtun-address'
      run_kwargs[:vtun_address] = arg
    when '--vtun-port'
      unless arg =~ /^[1-9][0-9]*$/ then
        STDERR.puts("ERROR: invalid port number (#{arg})")
        exit(1)
      end
      run_kwargs[:vtun_port] = arg.to_i
    end
  end

  if ARGV.length != 0 then
    STDERR.puts("ERROR: invalid number of arguments (#{ARGV.length}), expected 0")
    exit(1)
  end

  run(run_kwargs)
end

main
